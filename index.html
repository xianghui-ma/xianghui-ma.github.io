<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xianghui-ma.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="慢慢来，比较快！">
<meta property="og:type" content="website">
<meta property="og:title" content="Execute">
<meta property="og:url" content="https://xianghui-ma.github.io/index.html">
<meta property="og:site_name" content="Execute">
<meta property="og:description" content="慢慢来，比较快！">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="small_ma">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://xianghui-ma.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Execute</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Execute</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianghui-ma.github.io/2021/08/08/(15)%20generator%E7%94%9F%E6%88%90%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/img/header.png">
      <meta itemprop="name" content="small_ma">
      <meta itemprop="description" content="慢慢来，比较快！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Execute">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/08/(15)%20generator%E7%94%9F%E6%88%90%E5%99%A8/" class="post-title-link" itemprop="url">(15) generator生成器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-08 15:07:20" itemprop="dateCreated datePublished" datetime="2021-08-08T15:07:20+08:00">2021-08-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-20 10:58:55" itemprop="dateModified" datetime="2021-04-20T10:58:55+08:00">2021-04-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ES6/" itemprop="url" rel="index"><span itemprop="name">ES6</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="15-generator生成器"><a href="#15-generator生成器" class="headerlink" title="(15) generator生成器"></a>(15) generator生成器</h1><h3 id="generator的基本使用"><a href="#generator的基本使用" class="headerlink" title="generator的基本使用"></a>generator的基本使用</h3><p>我们可通过<code>function*</code>来定义一个<code>generator</code>函数。调用 <code>generator</code> 函数，返回一个遍历器对象。以后，每次调用遍历器对象的<code>next</code>方法，就会返回一个有着<code>value</code>和<code>done</code>两个属性的对象。<code>value</code>属性表示当前的内部状态的值，是<code>yield</code>表达式后面那个表达式的值；<code>done</code>属性是一个布尔值，表示是否遍历结束</p>
<p>遍历器对象中的<code>next</code>方法运行逻辑如下：</p>
<ol>
<li>遇到<code>yield</code>表达式，就暂停执行后面的操作，并将紧跟在<code>yield</code>后面的那个表达式的值，作为返回的对象的<code>value</code>属性值</li>
<li>下一次调用<code>next</code>方法时，再继续往下执行，直到遇到下一个<code>yield</code>表达式</li>
<li>如果没有再遇到新的<code>yield</code>表达式，就一直运行到函数结束，直到<code>return</code>语句为止，并将<code>return</code>语句后面的表达式的值，作为返回的对象的<code>value</code>属性值</li>
<li>如果该函数没有<code>return</code>语句，则返回的对象的<code>value</code>属性值为<code>undefined</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function* test()&#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">  return 4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let gen &#x3D; test();</span><br><span class="line">console.log(gen.next());</span><br><span class="line">console.log(gen.next());</span><br><span class="line">console.log(gen.next());</span><br><span class="line">console.log(gen.next());</span><br><span class="line">console.log(gen.next());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; &#123; value: 1, done: false &#125;</span><br><span class="line">&#x2F;&#x2F; &#123; value: 2, done: false &#125;       </span><br><span class="line">&#x2F;&#x2F; &#123; value: 3, done: false &#125;       </span><br><span class="line">&#x2F;&#x2F; &#123; value: 4, done: true &#125;        </span><br><span class="line">&#x2F;&#x2F; &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure>

<p><code>next</code>方法可以带一个参数，该参数就会被当作上一个<code>yield</code>表达式的返回值。由于<code>next</code>方法的参数表示上一个<code>yield</code>表达式的返回值，所以在第一次使用<code>next</code>方法时，传递参数是无效的。V8 引擎直接忽略第一次使用<code>next</code>方法时的参数，只有从第二次使用<code>next</code>方法开始，参数才是有效的。从语义上讲，第一个<code>next</code>方法用来启动遍历器对象，所以不用带有参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function* test()&#123;</span><br><span class="line">  let v1 &#x3D; yield 1;&#x2F;&#x2F;22作为yield表达式——“yield 1”——的返回值，赋给v1</span><br><span class="line">  console.log(v1);&#x2F;&#x2F;22</span><br><span class="line">  let v2 &#x3D; yield 2;&#x2F;&#x2F;33作为yield表达式——“yield 2”——的返回值，赋给v2</span><br><span class="line">  console.log(v2);&#x2F;&#x2F;33</span><br><span class="line">  let v3 &#x3D; yield 3;&#x2F;&#x2F;44作为yield表达式——“yield 3”——的返回值，赋给v3</span><br><span class="line">  console.log(v3);&#x2F;&#x2F;44</span><br><span class="line">  return 4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let gen &#x3D; test();</span><br><span class="line">console.log(gen.next(11));</span><br><span class="line">console.log(gen.next(22));</span><br><span class="line">console.log(gen.next(33));</span><br><span class="line">console.log(gen.next(44));</span><br><span class="line">console.log(gen.next(55));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; &#123; value: 1, done: false &#125;</span><br><span class="line">&#x2F;&#x2F;22</span><br><span class="line">&#x2F;&#x2F; &#123; value: 2, done: false &#125;  </span><br><span class="line">&#x2F;&#x2F;33     </span><br><span class="line">&#x2F;&#x2F; &#123; value: 3, done: false &#125; </span><br><span class="line">&#x2F;&#x2F;44      </span><br><span class="line">&#x2F;&#x2F; &#123; value: 4, done: true &#125;        </span><br><span class="line">&#x2F;&#x2F; &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure>

<h3 id="for…of…遍历"><a href="#for…of…遍历" class="headerlink" title="for…of…遍历"></a>for…of…遍历</h3><p><code>for...of</code>循环可以自动遍历 <code>generator</code> 函数调用时生成的遍历器对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function* test()&#123;</span><br><span class="line">  let v1 &#x3D; yield 1;</span><br><span class="line">  let v2 &#x3D; yield 2;</span><br><span class="line">  let v3 &#x3D; yield 3;</span><br><span class="line">  return 4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let gen &#x3D; test();</span><br><span class="line"></span><br><span class="line">for(let k of gen)&#123;</span><br><span class="line">  console.log(k);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;1</span><br><span class="line">&#x2F;&#x2F;2</span><br><span class="line">&#x2F;&#x2F;3</span><br></pre></td></tr></table></figure>

<p>这里需要注意，一旦<code>next</code>方法的返回对象的<code>done</code>属性为<code>true</code>，<code>for...of</code>循环就会中止，且不包含该返回对象，所以上面代码的<code>return</code>语句返回的4，不包括在<code>for...of</code>循环之中</p>
<h3 id="遍历器对象中的三个方法"><a href="#遍历器对象中的三个方法" class="headerlink" title="遍历器对象中的三个方法"></a>遍历器对象中的三个方法</h3><h4 id="Generator-prototype-throw"><a href="#Generator-prototype-throw" class="headerlink" title="Generator.prototype.throw()"></a>Generator.prototype.throw()</h4><p>该方法用于在<code>generator</code>函数体外抛出错误，然后在<code>generator</code>函数体内捕获错误</p>
<p>上面我们说过，可以通过带参数的<code>next</code>方法为<code>generator</code>函数内部传入参数，以作为<code>yield</code>表达式的返回值。这儿的<code>throw</code>方法实际上可以理解为<code>.next(new Error(...))</code>，即通过<code>next</code>向<code>generator</code>函数内部传入了一个错误，以作为<code>yield</code>表达式的返回值</p>
<p>同时，我们也可以为<code>throw</code>设置参数，该参数即为错误信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function* test()&#123;</span><br><span class="line">  try&#123;</span><br><span class="line">    let v1 &#x3D; yield 1;&#x2F;&#x2F;调用throw后，该行抛出错误</span><br><span class="line">	let v2 &#x3D; yield 2;</span><br><span class="line">  &#125;catch(e)&#123;</span><br><span class="line">    console.log(e);&#x2F;&#x2F;出错了</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let gen &#x3D; test();</span><br><span class="line">console.log(gen.next());&#x2F;&#x2F;&#123; value: 1, done: false &#125;</span><br><span class="line">gen.throw(&#39;出错了&#39;);&#x2F;&#x2F;相当于gen.next(new Error(&#39;出错了&#39;));</span><br></pre></td></tr></table></figure>

<p>通过<code>throw</code>抛出错误后，应该在<code>generator</code>函数体内的相应<code>yield</code>语句处用<code>try...catch...</code>捕获错误；如果没在<code>generator</code>函数中捕获错误，那么抛出的错误就会掉到调用<code>throw</code>方法处，你应该在该处捕获错误；如果在<code>generator</code>函数中和<code>throw</code>处都未捕获错误，那么整个脚本将终止执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function* test()&#123;</span><br><span class="line">  let v1 &#x3D; yield 1;</span><br><span class="line">&#125;</span><br><span class="line">let gen &#x3D; test();</span><br><span class="line">console.log(gen.next());&#x2F;&#x2F;&#123; value: 1, done: false &#125;</span><br><span class="line">try&#123;</span><br><span class="line">  gen.throw(&#39;出错了&#39;);&#x2F;&#x2F;相当于gen.next(new Error(&#39;出错了&#39;));</span><br><span class="line">&#125;catch(e)&#123;</span><br><span class="line">  console.log(e);&#x2F;&#x2F;出错了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是：</p>
<p>1、<code>throw</code>方法抛出的错误要被内部捕获，前提是必须至少执行过一次<code>next</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function* gen() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    yield 1;</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    console.log(&#39;内部捕获&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g &#x3D; gen();</span><br><span class="line">g.throw(1);</span><br><span class="line">&#x2F;&#x2F; Uncaught 1</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>g.throw(1)</code>执行时，<code>next</code>方法一次都没有执行过。这时，抛出的错误不会被内部捕获，而是直接在外部抛出，导致程序出错。这种行为其实很好理解，因为第一次执行<code>next</code>方法，等同于启动执行 <code>generator</code> 函数的内部代码，否则 <code>generator</code> 函数还没有开始执行，这时<code>throw</code>方法抛错只可能抛出在函数外部</p>
<p>2、<code>throw</code>方法被捕获以后，会附带执行下一条<code>yield</code>表达式。也就是说，会附带执行一次<code>next</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var gen &#x3D; function* gen()&#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    yield console.log(&#39;a&#39;);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line">  yield console.log(&#39;b&#39;);</span><br><span class="line">  yield console.log(&#39;c&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g &#x3D; gen();</span><br><span class="line">g.next() &#x2F;&#x2F; a</span><br><span class="line">g.throw() &#x2F;&#x2F; b</span><br><span class="line">g.next() &#x2F;&#x2F; c</span><br></pre></td></tr></table></figure>

<p>3、<code>generator</code> 函数体内抛出的错误，也可以被函数体外的<code>catch</code>捕获</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function* foo() &#123;</span><br><span class="line">  var x &#x3D; yield 3;</span><br><span class="line">  var y &#x3D; x.toUpperCase();</span><br><span class="line">  yield y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var it &#x3D; foo();</span><br><span class="line"></span><br><span class="line">it.next(); &#x2F;&#x2F; &#123; value:3, done:false &#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">  it.next(42);</span><br><span class="line">&#125; catch (err) &#123;</span><br><span class="line">  console.log(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，第二个<code>next</code>方法向函数体内传入一个参数 <code>42</code>，数值是没有<code>toUpperCase</code>方法的，所以会抛出一个 <code>TypeError</code> 错误，被函数体外的<code>catch</code>捕获</p>
<p>一旦 <code>generator</code> 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用<code>next</code>方法，将返回一个<code>value</code>属性等于<code>undefined</code>、<code>done</code>属性等于<code>true</code>的对象，即 <code>JavaScript</code> 引擎认为这个 <code>generator</code> 已经运行结束了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">function* g() &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  console.log(&#39;throwing an exception&#39;);</span><br><span class="line">  throw new Error(&#39;generator broke!&#39;);</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function log(generator) &#123;</span><br><span class="line">  var v;</span><br><span class="line">  console.log(&#39;starting generator&#39;);</span><br><span class="line">  try &#123;</span><br><span class="line">    v &#x3D; generator.next();</span><br><span class="line">    console.log(&#39;第一次运行next方法&#39;, v);</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    console.log(&#39;捕捉错误&#39;, v);</span><br><span class="line">  &#125;</span><br><span class="line">  try &#123;</span><br><span class="line">    v &#x3D; generator.next();</span><br><span class="line">    console.log(&#39;第二次运行next方法&#39;, v);</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    console.log(&#39;捕捉错误&#39;, v);</span><br><span class="line">  &#125;</span><br><span class="line">  try &#123;</span><br><span class="line">    v &#x3D; generator.next();</span><br><span class="line">    console.log(&#39;第三次运行next方法&#39;, v);</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    console.log(&#39;捕捉错误&#39;, v);</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(&#39;caller done&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(g());</span><br><span class="line">&#x2F;&#x2F; starting generator</span><br><span class="line">&#x2F;&#x2F; 第一次运行next方法 &#123; value: 1, done: false &#125;</span><br><span class="line">&#x2F;&#x2F; throwing an exception</span><br><span class="line">&#x2F;&#x2F; 捕捉错误 &#123; value: 1, done: false &#125;</span><br><span class="line">&#x2F;&#x2F; 第三次运行next方法 &#123; value: undefined, done: true &#125;</span><br><span class="line">&#x2F;&#x2F; caller done</span><br></pre></td></tr></table></figure>

<h4 id="Generator-prototype-return"><a href="#Generator-prototype-return" class="headerlink" title="Generator.prototype.return()"></a>Generator.prototype.return()</h4><p><code>generator</code> 函数返回的遍历器对象，还有一个<code>return()</code>方法，可以返回给定的值，并且终结遍历 <code>generator</code> 函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function* gen() &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g &#x3D; gen();</span><br><span class="line"></span><br><span class="line">g.next()        &#x2F;&#x2F; &#123; value: 1, done: false &#125;</span><br><span class="line">g.return(&#39;foo&#39;) &#x2F;&#x2F; &#123; value: &quot;foo&quot;, done: true &#125;</span><br><span class="line">g.next()        &#x2F;&#x2F; &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，遍历器对象<code>g</code>调用<code>return()</code>方法后，返回值的<code>value</code>属性就是<code>return()</code>方法的参数<code>foo</code>。并且，<code>generator</code> 函数的遍历就终止了，返回值的<code>done</code>属性为<code>true</code>，以后再调用<code>next()</code>方法，<code>done</code>属性总是返回<code>true</code></p>
<p>如果<code>return()</code>方法调用时，不提供参数，则返回值的<code>value</code>属性为<code>undefined</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function* gen() &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g &#x3D; gen();</span><br><span class="line"></span><br><span class="line">g.next()        &#x2F;&#x2F; &#123; value: 1, done: false &#125;</span><br><span class="line">g.return() &#x2F;&#x2F; &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure>

<p>如果 <code>generator</code> 函数内部有<code>try...finally</code>代码块，且正在执行<code>try</code>代码块，那么<code>return()</code>方法会导致立刻进入<code>finally</code>代码块，执行完以后，整个函数才会结束</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function* numbers () &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  try &#123;</span><br><span class="line">    yield 2;</span><br><span class="line">    yield 3;</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    yield 4;</span><br><span class="line">    yield 5;</span><br><span class="line">  &#125;</span><br><span class="line">  yield 6;</span><br><span class="line">&#125;</span><br><span class="line">var g &#x3D; numbers();</span><br><span class="line">g.next() &#x2F;&#x2F; &#123; value: 1, done: false &#125;</span><br><span class="line">g.next() &#x2F;&#x2F; &#123; value: 2, done: false &#125;</span><br><span class="line">g.return(7) &#x2F;&#x2F; &#123; value: 4, done: false &#125;</span><br><span class="line">g.next() &#x2F;&#x2F; &#123; value: 5, done: false &#125;</span><br><span class="line">g.next() &#x2F;&#x2F; &#123; value: 7, done: true &#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，调用<code>return()</code>方法后，就开始执行<code>finally</code>代码块，不执行<code>try</code>里面剩下的代码了，然后等到<code>finally</code>代码块执行完，再返回<code>return()</code>方法指定的返回值</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianghui-ma.github.io/2021/08/08/(14)%20async%E4%B8%8Eawait/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/img/header.png">
      <meta itemprop="name" content="small_ma">
      <meta itemprop="description" content="慢慢来，比较快！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Execute">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/08/(14)%20async%E4%B8%8Eawait/" class="post-title-link" itemprop="url">(14) async与await</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-08 15:07:20" itemprop="dateCreated datePublished" datetime="2021-08-08T15:07:20+08:00">2021-08-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-26 21:19:36" itemprop="dateModified" datetime="2021-06-26T21:19:36+08:00">2021-06-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ES6/" itemprop="url" rel="index"><span itemprop="name">ES6</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="14-async与await"><a href="#14-async与await" class="headerlink" title="(14) async与await"></a>(14) async与await</h1><p><code>async</code>与<code>await</code>是基于<code>promise</code>的，他们出现的目的就是为了简化<code>promise</code>的链式调用，使异步编程更加简洁和更具语义化</p>
<h3 id="什么是async与await"><a href="#什么是async与await" class="headerlink" title="什么是async与await"></a>什么是async与await</h3><p><code>async</code>被放在一个函数前面修饰函数。在函数前面加上<code>async</code>表达了两件事：一是，调用<code>async</code>函数会立即返回一个<code>Promise</code>对象；二是，可以在该函数中使用<code>await</code></p>
<p>什么是<code>await</code>呢？<code>await</code>后面应该是一个执行异步任务的<code>Promise</code>对象，当<code>async</code>函数中的代码在执行过程中遇见<code>await</code>时便会停在<code>await</code>的位置暂停向下执行，直到<code>Promise</code>对象的状态<code>settled</code>下来，然后再向下执行或结束返回（后面会说到）</p>
<p>下面看一下它们在代码中使用是什么样子（看不太懂也没事，后面还会继续讲解）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">async function test()&#123;</span><br><span class="line">  let result1 &#x3D; await new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    resolve(&#39;1&#39;);</span><br><span class="line">  &#125;);</span><br><span class="line">  console.log(result1);&#x2F;&#x2F;1</span><br><span class="line">  let result2 &#x3D; await new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    resolve(&#39;2&#39;);</span><br><span class="line">  &#125;);</span><br><span class="line">  console.log(result2);&#x2F;&#x2F;2</span><br><span class="line">  return result1 + result2;</span><br><span class="line">&#125;</span><br><span class="line">test().then((value) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(value);&#x2F;&#x2F;12</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>下面对<code>await</code>和其他核心内容做一个详细介绍。（你只需要明白<code>async</code>就是修饰函数的，表示这是一个执行异步任务的函数。因此不再赘述）</p>
<h3 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h3><h4 id="await"><a href="#await" class="headerlink" title="await"></a>await</h4><p><code>await</code>后面本应是<code>Promise</code>对象，但也可以是<code>thenable</code>对象（即定义了<code>then</code>方法的对象）、除<code>Promise</code>对象与<code>thenable</code>对象外的其他任何值（包括原始值和引用值）</p>
<p>后面的值不同，<code>await</code>的行为便有所不同。下面分别阐述在不同值下面的<code>await</code>行为：</p>
<p>1、<code>await</code>后面是<code>Promise</code>对象</p>
<p>如果<code>Promise</code>的状态为<code>resolved</code>，则<code>await</code>直接返回<code>resolve</code>函数传递出来的值。如果<code>Promise</code>的状态为<code>rejected</code>，则<code>await</code>不会返回值，而是直接抛出一个错误，错误信息就是<code>reject</code>函数传递出来的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">async function test()&#123;</span><br><span class="line">  let result1 &#x3D; await new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    resolve(&#39;1&#39;);</span><br><span class="line">  &#125;);</span><br><span class="line">  console.log(result1);&#x2F;&#x2F;1  await直接返回&#96;resolve&#96;函数传递出来的值</span><br><span class="line">  let result2 &#x3D; await new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    reject(&#39;2&#39;);</span><br><span class="line">    &#x2F;&#x2F;等同于</span><br><span class="line">    &#x2F;&#x2F; throw new Error(&#39;2&#39;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">test().catch((reason) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;出错了:&#39; + reason);&#x2F;&#x2F;出错了:2</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>2、<code>await</code>后面是除<code>Promise</code>对象与<code>thenable</code>对象外的其他任何值（包括原始值和引用值）</p>
<p>此时<code>await</code>不做任何处理，直接返回后面的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async function test()&#123;</span><br><span class="line">  let result1 &#x3D; await 123;</span><br><span class="line">  console.log(result1);&#x2F;&#x2F;123</span><br><span class="line">  let result2 &#x3D; await [1, 2, 3];</span><br><span class="line">  console.log(result2);&#x2F;&#x2F;[ 1, 2, 3 ]</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure>

<p>3、<code>await</code>后面是<code>thenable</code>对象</p>
<p>如果 <code>await</code> 接收了一个非 <code>promise</code> 的但是提供了 <code>.then</code> 方法的对象，它就会调用这个 <code>.then</code> 方法，并将内建的函数 <code>resolve</code> 和 <code>reject</code> 作为参数传入（这就是在创建<code>Promise</code>实例时的<code>resolve</code>与<code>reject</code>函数）。然后 <code>await</code> 等待直到这两个函数中的某个被调用。如果调用的是<code>resolve</code>，则<code>await</code>直接返回<code>resolve</code>函数传递出来的值；如果调用的是<code>reject</code>，则<code>await</code>不会返回值，而是直接抛出一个错误，错误信息就是<code>reject</code>函数传递出来的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Thenable &#123;</span><br><span class="line">  constructor(num) &#123;</span><br><span class="line">    this.num &#x3D; num;</span><br><span class="line">  &#125;</span><br><span class="line">  then(resolve, reject) &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; reject(this.num * 2), 1000); &#x2F;&#x2F; (*)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">async function f() &#123;</span><br><span class="line">  try&#123;</span><br><span class="line">    let result &#x3D; await new Thenable(1);</span><br><span class="line">    &#x2F;&#x2F;等同于</span><br><span class="line">    &#x2F;&#x2F; throw new Error(2);</span><br><span class="line">  &#125;catch(err)&#123;</span><br><span class="line">    console.log(err);&#x2F;&#x2F;2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br></pre></td></tr></table></figure>

<h4 id="async函数中的return"><a href="#async函数中的return" class="headerlink" title="async函数中的return"></a>async函数中的return</h4><p>前面说了“调用<code>async</code>函数会立即返回一个<code>Promise</code>对象”，这与<code>return</code>无关（即<code>Promise</code>对象不是用书写<code>return</code>返回的，与<code>return</code>无关）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">async function f() &#123;&#125;</span><br><span class="line">console.log(f());&#x2F;&#x2F;Promise &#123; undefined &#125;</span><br></pre></td></tr></table></figure>

<p>可见，只要调用<code>async</code>函数就会返回<code>Promise</code>对象，</p>
<p><code>return</code>通常用于返回<code>async</code>函数中异步操作返回的结果，<code>return</code>返回的值会被传给<code>then</code>（<code>async</code>函数会返回一个<code>Promise</code>对象，所以可以调用该对象的<code>then</code>方法）中的<code>resolveCallback</code>回调函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async function f() &#123;</span><br><span class="line">  let result &#x3D; await new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    resolve(1);</span><br><span class="line">  &#125;);</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line">f().then((value) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(value);&#x2F;&#x2F;1</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="async函数返回的Promise对象的状态"><a href="#async函数返回的Promise对象的状态" class="headerlink" title="async函数返回的Promise对象的状态"></a>async函数返回的Promise对象的状态</h4><p><code>async</code>函数返回的 <code>Promise</code> 对象，必须等到内部所有<code>await</code>命令后面的 <code>Promise</code> 对象执行完，才会发生状态改变，除非遇到<code>return</code>语句或者抛出错误（下面在“async”函数的执行流程中会详细说）。且只有当所有<code>await</code>命令后面的 <code>Promise</code> 对象都为<code>resolved</code>状态，那么<code>async</code>函数返回的 <code>Promise</code> 对象才为<code>resolved</code>状态；只要有一个是<code>rejected</code>状态，则<code>async</code>函数返回的 <code>Promise</code> 对象就为<code>reject</code>状态</p>
<p>同时，<code>async</code>函数内部抛出错误（见下面“async函数的执行流程 - 3”），会导致返回的 <code>Promise</code> 对象变为<code>rejected</code>状态</p>
<h4 id="async函数的执行流程"><a href="#async函数的执行流程" class="headerlink" title="async函数的执行流程"></a>async函数的执行流程</h4><p>从整体看，<code>async</code>函数的执行流程为：调用<code>async</code>函数开始执行 ——&gt; 遇见<code>await</code>则暂停执行等待异步操作完成再向下执行</p>
<p>但在执行过程中遇到下述两种情况时，<code>async</code>函数会立即中断整个<code>async</code>函数的执行并跳出</p>
<p>1、遇见<code>return</code>语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">async function f() &#123;</span><br><span class="line">  return null;</span><br><span class="line">  let promise &#x3D; await new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    resolve(22);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then((value) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(value);&#x2F;&#x2F;null</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;******&#x2F;</span><br><span class="line"></span><br><span class="line">async function f() &#123;</span><br><span class="line">  let promise1 &#x3D; await new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    resolve(22);</span><br><span class="line">  &#125;);</span><br><span class="line">  return 123;</span><br><span class="line">  let promise2 &#x3D; await new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    resolve(33);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then((value) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(value);&#x2F;&#x2F;123</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>2、<code>await</code>后面的<code>Promise</code>对象为<code>rejected</code>状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">async function f() &#123;</span><br><span class="line">  let promise1 &#x3D; await new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    reject(22);</span><br><span class="line">  &#125;);</span><br><span class="line">  console.log(&#39;继续需执行？&#39;);&#x2F;&#x2F;不会执行</span><br><span class="line">  let promise2 &#x3D; await new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    resolve(33);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then((value) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;).catch((reason) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(reason);&#x2F;&#x2F;22</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>3、<code>async</code>函数内部抛出错误(不是在里面的<code>Promise</code>中抛出错误)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">async function f() &#123;</span><br><span class="line">  throw new Error(123);</span><br><span class="line">  console.log(&#39;继续需执行？&#39;);&#x2F;&#x2F;不会执行</span><br><span class="line">  let promise1 &#x3D; await new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    reject(22);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then((value) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;).catch((reason) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;出错了&#39; + reason);&#x2F;&#x2F;出错了Error: 123</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="其他要注意的内容"><a href="#其他要注意的内容" class="headerlink" title="其他要注意的内容"></a>其他要注意的内容</h3><p>1、前面我们知道，任何一个<code>await</code>语句后面的 <code>Promise</code> 对象变为<code>rejected</code>状态，那么整个<code>async</code>函数都会中断执行。有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将那个<code>await</code>放在<code>try...catch</code>结构里面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">async function f() &#123;</span><br><span class="line">  try&#123;</span><br><span class="line">    let result1 &#x3D; await new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      reject(22);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;catch(err)&#123;</span><br><span class="line">    console.log(err);&#x2F;&#x2F;22</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(&#39;继续需执行&#39;);&#x2F;&#x2F;继续需执行</span><br><span class="line">  let result2 &#x3D; await new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    resolve(33);</span><br><span class="line">  &#125;);</span><br><span class="line">  return result2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then((value) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(value);&#x2F;&#x2F;33</span><br><span class="line">&#125;).catch((reason) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>为什么能用<code>try...catch...</code>捕获呢？因为，如果 <code>Promise</code> 被 <code>rejected</code>，<code>await</code>将 <code>throw</code> 这个 <code>error</code>，就像在这一行有一个 <code>throw</code> 语句那样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async function f() &#123;</span><br><span class="line">  await Promise.reject(new Error(&quot;Whoops!&quot;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;等同于</span><br><span class="line"></span><br><span class="line">async function f() &#123;</span><br><span class="line">  throw new Error(&quot;Whoops!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、<code>async</code> 函数有多种使用形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 函数声明</span><br><span class="line">async function foo() &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 函数表达式</span><br><span class="line">const foo &#x3D; async function () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对象的方法</span><br><span class="line">let obj &#x3D; &#123; async foo() &#123;&#125; &#125;;</span><br><span class="line">obj.foo().then(...)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Class 的方法</span><br><span class="line">class Storage &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.cachePromise &#x3D; caches.open(&#39;avatars&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async getAvatar(name) &#123;</span><br><span class="line">    const cache &#x3D; await this.cachePromise;</span><br><span class="line">    return cache.match(&#96;&#x2F;avatars&#x2F;$&#123;name&#125;.jpg&#96;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const storage &#x3D; new Storage();</span><br><span class="line">storage.getAvatar(&#39;jake&#39;).then(…);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 箭头函数</span><br><span class="line">const foo &#x3D; async () &#x3D;&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>基本上，函数出现的位置都能用</p>
<p>3、<code>await</code>只能用在<code>async</code>函数中</p>
<p>4、对于<code>async</code>函数而言，如果其显示的<code>return</code>一个<code>promise</code>，那么<code>async</code>函数返回的<code>promise</code>就是显示的<code>return</code>的那个<code>promise</code>。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async (username) &#x3D;&gt; &#123;</span><br><span class="line">    let user &#x3D; await userCol.findOne(&#123; username &#125;).exec();</span><br><span class="line">    if(user)&#123;</span><br><span class="line">        return Promise.reject(&#39;用户名已存在&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述如果用户名已存在，则<code>async</code>函数返回的<code>promise</code>就是<code>Promise.reject(&#39;用户名已存在&#39;)</code>，即一个失败状态的<code>promise</code></p>
<p>5、在实战中我们需要处理<code>await</code>后面的异步操作失败的情况（你却不知如何处理！！！）。在上面 <strong>其他要注意的内容</strong>一节中的<code>1</code>小点和 <strong>详细介绍</strong>下的 <strong>await</strong>一节中的<code>1</code>小点已经说得很明白了，直接用<code>try...catch...</code>处理就行了</p>
<h3 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h3><p>下面我们将<code>Promise</code>一章中读取文件的例子改用使用<code>async与await</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Promise写法</span><br><span class="line">const p &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  fs.readFile(&#39;.&#x2F;resources&#x2F;为学.md&#39;, (err, data) &#x3D;&gt; &#123;</span><br><span class="line">    resolve(data);&#x2F;&#x2F;读取成功后将结果传给then中注册的resolveCallback回调函数</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then((value) &#x3D;&gt; &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    fs.readFile(&#39;.&#x2F;resources&#x2F;插秧诗.md&#39;, (err, data) &#x3D;&gt; &#123;</span><br><span class="line">      resolve([data, value]);&#x2F;&#x2F;读取成功后将结果传给then中注册的resolveCallback回调函数</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).then((value) &#x3D;&gt; &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    fs.readFile(&#39;.&#x2F;resources&#x2F;观书有感.md&#39;, (err, data) &#x3D;&gt; &#123;</span><br><span class="line">      resolve(value.push(data));&#x2F;&#x2F;读取成功后将结果传给then中注册的resolveCallback回调函数</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).then((value) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(value[0] + value[1] + value[2]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;async与await写法</span><br><span class="line">async function getFile()&#123;</span><br><span class="line">  let text1 &#x3D; await new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    fs.readFile(&#39;.&#x2F;resources&#x2F;为学.md&#39;, (err, data) &#x3D;&gt; &#123;</span><br><span class="line">      resolve(data);&#x2F;&#x2F;读取成功后,结果由await返回给text1</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  let text2 &#x3D; await new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    fs.readFile(&#39;.&#x2F;resources&#x2F;插秧诗.md&#39;, (err, data) &#x3D;&gt; &#123;</span><br><span class="line">      resolve(data);&#x2F;&#x2F;读取成功后,结果由await返回给text2</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  let text3 &#x3D; await new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    fs.readFile(&#39;.&#x2F;resources&#x2F;观书有感.md&#39;, (err, data) &#x3D;&gt; &#123;</span><br><span class="line">      resolve(data);&#x2F;&#x2F;读取成功后,结果由await返回给text3</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  return [text1, text2, text3];&#x2F;&#x2F;将结果给then中的value</span><br><span class="line">&#125;</span><br><span class="line">getFile().then((value) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(value[0] + value[1] + value[2]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianghui-ma.github.io/2021/08/08/(13)%20%E6%A8%A1%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/img/header.png">
      <meta itemprop="name" content="small_ma">
      <meta itemprop="description" content="慢慢来，比较快！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Execute">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/08/(13)%20%E6%A8%A1%E5%9D%97/" class="post-title-link" itemprop="url">(13) 模块</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-08 15:07:20" itemprop="dateCreated datePublished" datetime="2021-08-08T15:07:20+08:00">2021-08-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-21 17:14:55" itemprop="dateModified" datetime="2021-06-21T17:14:55+08:00">2021-06-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ES6/" itemprop="url" rel="index"><span itemprop="name">ES6</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="13-模块"><a href="#13-模块" class="headerlink" title="(13) 模块"></a>(13) 模块</h1><h3 id="在浏览器中加载模块"><a href="#在浏览器中加载模块" class="headerlink" title="在浏览器中加载模块"></a>在浏览器中加载模块</h3><p>在浏览器中加载模块有如下两种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;module&quot; src&#x3D;&quot;......&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;module&quot;&gt;</span><br><span class="line">	&#x2F;&#x2F;通过import引入模块</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>对于第一种方式，浏览器会异步加载模块，并等到整个页面渲染完成再执行模块</p>
<p>模块功能主要由两个命令构成：<code>export</code>和<code>import</code>。<code>export</code>命令用于规定模块的对外接口，<code>import</code>命令用于输入其他模块提供的功能。下面分别阐述它们</p>
<h3 id="export导出"><a href="#export导出" class="headerlink" title="export导出"></a>export导出</h3><p>export可用于导出变量、函数和类</p>
<p><code>export</code>有三种导出方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*在声明时导出*&#x2F;</span><br><span class="line">export let name &#x3D; &#39;德洛丽丝&#39;;</span><br><span class="line">export function getName()&#123;</span><br><span class="line">  console.log(&#39;伯纳德&#39;);</span><br><span class="line">&#125;</span><br><span class="line">export class A&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*导出与声明分开（集中导出）*&#x2F;</span><br><span class="line">let name &#x3D; &#39;德洛丽丝&#39;;</span><br><span class="line">function getName()&#123;</span><br><span class="line">  console.log(&#39;伯纳德&#39;);</span><br><span class="line">&#125;</span><br><span class="line">class A&#123;&#125;</span><br><span class="line">export &#123;&#x2F;&#x2F;实际上是导出后面的对象</span><br><span class="line">  name,</span><br><span class="line">  getName,</span><br><span class="line">  A</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*export as*&#x2F;</span><br><span class="line">let name &#x3D; &#39;德洛丽丝&#39;;</span><br><span class="line">function getName()&#123;</span><br><span class="line">  console.log(&#39;伯纳德&#39;);</span><br><span class="line">&#125;</span><br><span class="line">class A&#123;&#125;</span><br><span class="line">export &#123;</span><br><span class="line">  name as index_name,</span><br><span class="line">  getName as index_getName,</span><br><span class="line">  A as index_A</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>export as</code>能够让导出不同的名字，如上述<code>name</code>将以别名<code>index_name</code>导出。<code>export as</code>只能用于<code>导出与声明分开（集中导出)</code>的方式</p>
<h3 id="import引入"><a href="#import引入" class="headerlink" title="import引入"></a>import引入</h3><p>引入也有三种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*按需引入(即只引入需要的变量&#x2F;函数&#x2F;类) import &#123;...&#125; from URL*&#x2F;</span><br><span class="line">import &#123;getName&#125; from &#39;URL&#39;;&#x2F;&#x2F;只引入getName函数</span><br><span class="line"></span><br><span class="line">&#x2F;*全部引入（即将导出的所有内容都引入）import * as &lt;obj&gt; from URL*&#x2F;</span><br><span class="line">import * as indexJS from URL;</span><br><span class="line">indexJS.getName();</span><br><span class="line"></span><br><span class="line">&#x2F;*import as*&#x2F;</span><br><span class="line">import &#123;getName as index_getName&#125; from URL;</span><br></pre></td></tr></table></figure>

<p><code>全部引入</code>会将所有导出的内容放于<code>&lt;obj&gt;</code>对象中。<code>import as</code>同<code>export as</code>作用一样，用于起一个新名字</p>
<p>除了上述<code>import</code>的基本用法外，我们还可以看见如下写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Button, Input &#125; from &#39;antd&#39;;&#x2F;&#x2F;&lt;1&gt;</span><br><span class="line">import &#39;.&#x2F;App.css&#39;&#x2F;&#x2F;&lt;2&gt;</span><br></pre></td></tr></table></figure>

<p>第&lt;1&gt;种写法<code>from</code>后面不是一个路径，而是一个模块名，这种只写模块名的写法要求通过配置文件告诉引擎在哪儿找这个模块</p>
<p><code>import</code>语句会执行所加载的模块，因此可以有第&lt;2&gt;种写法</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianghui-ma.github.io/2021/08/08/(12)%20Class/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/img/header.png">
      <meta itemprop="name" content="small_ma">
      <meta itemprop="description" content="慢慢来，比较快！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Execute">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/08/(12)%20Class/" class="post-title-link" itemprop="url">(12) class</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-08 15:07:20" itemprop="dateCreated datePublished" datetime="2021-08-08T15:07:20+08:00">2021-08-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-16 08:31:26" itemprop="dateModified" datetime="2021-04-16T08:31:26+08:00">2021-04-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ES6/" itemprop="url" rel="index"><span itemprop="name">ES6</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="12-class"><a href="#12-class" class="headerlink" title="(12) class"></a>(12) class</h1><h3 id="定义一个类"><a href="#定义一个类" class="headerlink" title="定义一个类"></a>定义一个类</h3><p>ES6中通过如下方式定义一个类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class 类名&#123;</span><br><span class="line">	constructor(参数列表)&#123;</span><br><span class="line">		this.. &#x3D; ...;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;类的属性与方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后通过<code>new 类名()</code>的方式创建这个类的实例。其中<code>constructor()</code>方法是类的默认方法，通过<code>new</code>命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor()</code>方法，如果没有显式定义，一个空的<code>constructor()</code>方法会被默认添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***ES5写法***&#x2F;</span><br><span class="line">function Point(x, y)&#123;</span><br><span class="line">  this.x &#x3D; x;</span><br><span class="line">  this.y &#x3D; y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;***class写法***&#x2F;</span><br><span class="line">class Point&#123;</span><br><span class="line">  constructor(x, y)&#123;</span><br><span class="line">    this.x &#x3D; x;</span><br><span class="line">    this.y &#x3D; y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let point &#x3D; new Point(1, 2);</span><br><span class="line">console.log(point);&#x2F;&#x2F;Point &#123; x: 1, y: 2 &#125;</span><br></pre></td></tr></table></figure>

<p>类也有原型，类的原型就是<code>类名</code>后面的<code>&#123;...&#125;</code>，也就是说上面的<code>constructor</code>与<code>//类的属性与方法</code>实际上都是定义在类的原型上，然后类的所有实例共享该原型，即实例的原型就是类的原型（即都拥有这些内容，这与ES5一样）。可通过<code>类名.prototype</code>获取类的原型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***ES5***&#x2F;</span><br><span class="line">function Point(x, y)&#123;</span><br><span class="line">  this.x &#x3D; x;</span><br><span class="line">  this.y &#x3D; y;</span><br><span class="line">&#125;</span><br><span class="line">console.log(Point.prototype.constructor &#x3D;&#x3D;&#x3D; Point);&#x2F;&#x2F;true</span><br><span class="line"></span><br><span class="line">&#x2F;***ES6***&#x2F;</span><br><span class="line">class Point&#123;</span><br><span class="line">  constructor(x, y)&#123;</span><br><span class="line">    this.x &#x3D; x;</span><br><span class="line">    this.y &#x3D; y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(Point.prototype.constructor &#x3D;&#x3D;&#x3D; Point);&#x2F;&#x2F;true</span><br><span class="line">console.log(point.__proto__ &#x3D;&#x3D;&#x3D; Point.prototype);&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<p>可见，<code>类名</code>实际上就指向了该类的构造函数</p>
<p>定义类的属性与方法时，不需要加逗号分隔，不需要写成键值对形式。同时，我们在定义类的属性时，一般将属性写在类的最前面，以便清晰地展现该类有哪些属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Point&#123;</span><br><span class="line">  _type &#x3D; &#39;default&#39;;&#x2F;&#x2F;定义一个属性</span><br><span class="line">  constructor(x, y)&#123;</span><br><span class="line">    this.x &#x3D; x;</span><br><span class="line">    this.y &#x3D; y;</span><br><span class="line">  &#125;</span><br><span class="line">  test()&#123;&#x2F;&#x2F;定义一个方法</span><br><span class="line">    console.log(&#39;test&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let point &#x3D; new Point();</span><br><span class="line">console.log(point._type);&#x2F;&#x2F;default</span><br><span class="line">point.test();&#x2F;&#x2F;test</span><br></pre></td></tr></table></figure>

<p>我们可通过<code>[]</code>动态设置类的属性与方法名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let str1 &#x3D; &#39;_type&#39;;</span><br><span class="line">let str2 &#x3D; &#39;test&#39;;</span><br><span class="line">class Point&#123;</span><br><span class="line">  [str1] &#x3D; &#39;default&#39;;</span><br><span class="line">  constructor(x, y)&#123;</span><br><span class="line">    this.x &#x3D; x;</span><br><span class="line">    this.y &#x3D; y;</span><br><span class="line">  &#125;</span><br><span class="line">  [str2]()&#123;</span><br><span class="line">    console.log(&#39;test&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let point &#x3D; new Point();</span><br><span class="line">console.log(point._type);&#x2F;&#x2F;default</span><br><span class="line">point.test();&#x2F;&#x2F;test</span><br></pre></td></tr></table></figure>

<p>与函数一样，类也可以使用表达式定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const MyClass &#x3D; class Me &#123;</span><br><span class="line">	&#x2F;&#x2F;类的属性与方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">const MyClass &#x3D; class &#123; &#x2F;&#x2F;类的属性与方法 &#125;</span><br></pre></td></tr></table></figure>

<p>上述第一种方式中的<code>Me</code>只能在<code>class</code>内部使用（即<code>类名</code>后的<code>&#123;&#125;</code>中使用）指代类本身。在 <code>class</code> 外部，这个类只能用<code>MyClass</code>引用</p>
<p>采用 <code>class</code> 表达式，可以写出立即执行的 <code>class</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let person &#x3D; new class &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayName() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(&#39;张三&#39;);</span><br><span class="line"></span><br><span class="line">person.sayName(); &#x2F;&#x2F; &quot;张三&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>person</code>是一个立即执行的类的实例</p>
<p>上面我们说“<code>//类的属性与方法</code>实际上都是定义在类的原型上”。但这种说法是错的，在此做一个订正：</p>
<p><code>类的方法</code>确实是定义在类的原型上的。但是<code>类的属性</code>(如前面代码中的<code>_type</code>)不是定义在类的原型上的，而是定义在实例上的。这只是“定义实例属性的一种新写法”。这种新写法详述如下：</p>
<p>实例属性除了定义在<code>constructor()</code>方法里面的<code>this</code>上面，也可以定义在<code>constructor</code>之外的类的最顶层（这时，不需要在实例属性前面加上<code>this</code>）。这种新写法的好处是，所有实例对象自身的属性都定义在类的头部，看上去比较整齐，一眼就能看出这个类有哪些实例属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; class A &#123;</span><br><span class="line">&#x2F;&#x2F;   constructor()&#123;</span><br><span class="line">&#x2F;&#x2F;     this.x &#x3D; 2;</span><br><span class="line">&#x2F;&#x2F;   &#125;</span><br><span class="line">&#x2F;&#x2F; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;***新写法***&#x2F;</span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">  x &#x3D; 2;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    &#x2F;&#x2F; this.x &#x3D; 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let a &#x3D; new A();</span><br><span class="line">console.log(a.x);&#x2F;&#x2F;2</span><br><span class="line">console.log(A.prototype.x);&#x2F;&#x2F;undefined</span><br></pre></td></tr></table></figure>

<p>可见类属性并未定义在类的原型上</p>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>前面说了——类的原型就是实例的原型，因此类中的所有方法为各实例共享。但如果在一个方法前，加上<code>static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">  static classMethod() &#123;</span><br><span class="line">    return &#39;hello&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.classMethod() &#x2F;&#x2F; &#39;hello&#39;</span><br><span class="line"></span><br><span class="line">var foo &#x3D; new Foo();</span><br><span class="line">foo.classMethod()</span><br><span class="line">&#x2F;&#x2F; TypeError: foo.classMethod is not a function</span><br></pre></td></tr></table></figure>

<p>父类的静态方法可以被子类继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">  static classMethod() &#123;</span><br><span class="line">    return &#39;hello&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bar extends Foo &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bar.classMethod() &#x2F;&#x2F; &#39;hello&#39;</span><br></pre></td></tr></table></figure>

<p>静态方法中的<code>this</code>关键字指的是类本身，而不是实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">  static bar() &#123;</span><br><span class="line">    this.baz();</span><br><span class="line">  &#125;</span><br><span class="line">  static baz() &#123;</span><br><span class="line">    console.log(&#39;hello&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">  baz() &#123;</span><br><span class="line">    console.log(&#39;world&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.bar() &#x2F;&#x2F; hello</span><br></pre></td></tr></table></figure>

<p>从这个例子还可以看出，静态方法可以与非静态方法重名。特别注意的是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">  static bar() &#123;</span><br><span class="line">    this.baz();</span><br><span class="line">  &#125;</span><br><span class="line">  baz() &#123;</span><br><span class="line">    console.log(&#39;world&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.bar() &#x2F;&#x2F; TypeError: this.baz is not a function</span><br></pre></td></tr></table></figure>

<p>因为<code>this</code>指向类本身，所以<code>this.baz()</code>表示用类调用方法，而只有静态方法才能被类调用，但是上述<code>baz</code>不是静态方法，所以报错</p>
<h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><p>在第一节中我们已经展示了如何在类中定义所有实例的共享属性。但如果在一个属性前，加上<code>static</code>关键字，就表示该属性不会被实例继承，而是直接通过类来调用，这就称为“静态属性”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">  static type &#x3D; 123;</span><br><span class="line">&#125;</span><br><span class="line">let foo &#x3D; new Foo();</span><br><span class="line">console.log(foo.type);&#x2F;&#x2F;undefined</span><br><span class="line">console.log(Foo.type);&#x2F;&#x2F;123</span><br></pre></td></tr></table></figure>

<p>静态属性也可以被子类继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  static type &#x3D; 123;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(B.type);&#x2F;&#x2F;123</span><br></pre></td></tr></table></figure>

<h3 id="私有属性与方法"><a href="#私有属性与方法" class="headerlink" title="私有属性与方法"></a>私有属性与方法</h3><p>以<code>#</code>开头的<code>属性名/方法名</code>表示私有<code>属性/方法</code>。私有属性和方法不能被子类继承、不能由实例使用、不能在类的外部使用、只能在类的内部通过<code>this.#......</code>的形式调用（这儿的<code>this</code>指向的是实例，具体见下面“一些注意点——6”）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">  #type &#x3D; 123;</span><br><span class="line">  #test()&#123;</span><br><span class="line">    console.log(this.#type);</span><br><span class="line">  &#125;</span><br><span class="line">  print()&#123;</span><br><span class="line">    this.#test();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let foo &#x3D; new Foo();</span><br><span class="line">foo.print();&#x2F;&#x2F;123</span><br><span class="line">&#x2F;&#x2F; console.log(foo.#type);&#x2F;&#x2F;SyntaxError: Private field &#39;#type&#39; must be declared in an enclosing class</span><br></pre></td></tr></table></figure>



<p>私有属性和私有方法前面，也可以加上<code>static</code>关键字，表示这是一个静态的私有属性或私有方法</p>
<blockquote>
<p>浏览器对<code>#</code>支持不太好</p>
</blockquote>
<h3 id="一些注意点"><a href="#一些注意点" class="headerlink" title="一些注意点"></a>一些注意点</h3><p>1、类的内部所有定义的方法，都是不可枚举的（non-enumerable）</p>
<p>2、类必须使用<code>new</code>调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用<code>new</code>也可以执行</p>
<p>3、与 ES5 一样，在“类”的内部可以使用<code>get</code>和<code>set</code>关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line">  get prop() &#123;</span><br><span class="line">    return &#39;getter&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">  set prop(value) &#123;</span><br><span class="line">    console.log(&#39;setter: &#39;+value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let inst &#x3D; new MyClass();</span><br><span class="line"></span><br><span class="line">inst.prop &#x3D; 123;</span><br><span class="line">&#x2F;&#x2F; setter: 123</span><br><span class="line"></span><br><span class="line">inst.prop</span><br><span class="line">&#x2F;&#x2F; &#39;getter&#39;</span><br></pre></td></tr></table></figure>

<p>4、类和模块的内部，默认就是严格模式，所以不需要使用<code>use strict</code>指定运行模式</p>
<p>5、类不存在变量提升（hoist），这一点与 ES5 完全不同</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new Foo(); &#x2F;&#x2F; ReferenceError</span><br><span class="line">class Foo &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，Foo类使用在前，定义在后，这样会报错，因为 ES6 不会把类的声明提升到代码头部</p>
<p>6、静态方法中的<code>this</code>指向类本身，而非静态方法中的<code>this</code>指向实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">  #type &#x3D; 123;</span><br><span class="line">  static fun()&#123;</span><br><span class="line">    console.log(this &#x3D;&#x3D;&#x3D; Foo);&#x2F;&#x2F;true</span><br><span class="line">  &#125;</span><br><span class="line">  #test()&#123;</span><br><span class="line">    console.log(this &#x3D;&#x3D;&#x3D; foo);&#x2F;&#x2F;true</span><br><span class="line">    console.log(this.#type);</span><br><span class="line">  &#125;</span><br><span class="line">  print()&#123;</span><br><span class="line">    console.log(this &#x3D;&#x3D;&#x3D; foo);&#x2F;&#x2F;true</span><br><span class="line">    this.#test();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let foo &#x3D; new Foo();</span><br><span class="line">foo.print();&#x2F;&#x2F;123</span><br><span class="line">Foo.fun();</span><br></pre></td></tr></table></figure>

<p>但是，必须非常小心，一旦单独使用该方法，很可能报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Logger &#123;</span><br><span class="line">  printName(name &#x3D; &#39;there&#39;) &#123;</span><br><span class="line">    this.print(&#96;Hello $&#123;name&#125;&#96;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  print(text) &#123;</span><br><span class="line">    console.log(text);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const logger &#x3D; new Logger();</span><br><span class="line">const &#123; printName &#125; &#x3D; logger;</span><br><span class="line">printName(); &#x2F;&#x2F; TypeError: Cannot read property &#39;print&#39; of undefined</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>printName</code>方法中的<code>this</code>，默认指向<code>Logger</code>类的实例。但是，如果将这个方法提取出来单独使用，<code>this</code>会指向该方法运行时所在的环境（由于 <code>class</code> 内部是严格模式，所以 <code>this</code> 实际指向的是<code>undefined</code>），从而导致找不到<code>print</code>方法而报错</p>
<p>至此，类的基本知识已经讨论完毕。下面我们讨论类的继承相关内容</p>
<h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><h4 id="继承语法"><a href="#继承语法" class="headerlink" title="继承语法"></a>继承语法</h4><p>我们通过语法<code>class Child extends Father</code>表示继承。继承实现的原理是：将子类的原型中的原型设置为父类的原型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;&#125;</span><br><span class="line">class B extends A&#123;&#125;</span><br><span class="line"></span><br><span class="line">console.log(B.prototype.__proto__ &#x3D;&#x3D;&#x3D; A.prototype);&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<p>上述代码的继承原理如下图所示：</p>
<p><img src="data:image/png;base64,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CLI+N+8uMPadgNgZK2rDj8t878SkpGkIDbQOaqDvd8zPFiMuyslsa+r1GiMCUlA3m8EQjGEIvkPsy6/FftqHH6l/HJ78mTyt2HqbeKzAKESI/UucbhN+pLZ4T1rMf3DiZL5+SZuNeBV+pNv6M/wQkXthBYjcFitA1BxNGQTBXU6Na8kKEFFrs63yOPXUX1Gz+gG1QtcCK0BEDbECREQez1MHSyBqNTFDkfjBvxh+iMgtMQARESkMQkSNd/OMHagxf+f4sk/OAcRT34jIPTEAUbvg5eWllohaH4MQERFRx8U+QOS22qoPkDzQJbqStuojxD5ARNTS2AeIqCFWgKhdYAWIriVWhIiIiDoOBiBqFxpZqCRqFbICFPhGWqtXgRj0iYiIWh9PgSO3xWGwqTmaMgy2M209PLY8/U2eBifxFDgiagk8BY6oIVaAiIjstFXFh4iIiNoeAxARkcLgQ0RE1PExABGRx2PwISIi8hwMQETksRh8iIiIPA8DEBF5HBl4GHyIiIg8EwMQEXkMa8VHXhMREZFnYgAiog6Pp7oRERGRFQMQEXVYDD5ERERkjwGIiDokGX4YfIiIiMgeAxAREREREXkMBiAiIiIiIvIYDEBEREREROQxGICIiIiIiMhjMAAREREREZHHYAAiIiIiIiKPwQBEREREREQegwGIiIiIiIg8BgMQERERERF5DAYgIiIiIiLyGAxARERERETkMRiAiIiIiIjIYzAAERERERGRx2AAIiIiIiIij8EAREREREREHoMBiIiIiIiIPAYDEBEREREReQwGICIiIiIi8hgMQERERERE5DEYgIiIiIiIyGMwABERERERkcdgACIiIiIiIo/BAERERERERB6DAYiIiIiIiDyGV42glq+oeP8KtQR07XW7WtLViP95if85u7Zq7HZWjd3+SttZObvdfjurxm5/te3st6fGk6/dhVOfa8vG3jHoGjZMWybqqEyFmbhQkKEtG3tF1fv8kMuSo88TZ58zrd3eWNfq+Tlrb6xr9fyctRO5wnQqWy0BIffMUktEns2lAETU1hiAyBPYBiAiopbGAESk4ylwRERERETkMRpdAZK/TEpycy8vm9PP7NatbNutD9GU7a50f2fbUccl32dWgKijk5+z9p9vVvafd/bbNaVdas79r9Rur6Xvb+Xo/rbs21v7/lau/F25bL22sl+3ctZO1BjybAoiEp/B4sO0/qc3ERERERFRB8VT4IiIiIiIyGMwABERERERkcdgACIiIiIiIo/BAERERERERB6DAYiIiIiIiDwGAxAREREREXkMBiAiIiIiIvIYDEBEREREROQxGICIiIiIiMhjMAAREREREZHHYAAiIiIiIiKPwQBEREREREQegwGIiIiIiIg8BgMQERERERF5DAYgIiIiIiLyGAxARERERETkMRiAiIiIiIjIYzAAERERERGRx2AAIiIiIiIij8EAREREREREHoMBiIiIiIiIPAYDEBERkRurqapUS0RE1BIYgIiIiNxYxcbVsJw5ra8QEVGzMQARERG5KRl8zP/ahYqdf1EtRETUXAxAREREbkoLPhYLKg9+zCoQEVELYQAiIiJyQzLwyOCjr1hYBSIiaiEMQERERG7IWv2xYhWIiKhlMAARERG5mXrVHytWgYiIWgQDEBERkZuxr/5YsQpERNR8DEBERERuxGH1x4pVICKiZmMAIiIiciPOqj9WrAIRETUPAxAREZGbuGL1x4pVICKiZmEAIiIichNXq/5YsQpEROQ6BiAiIiI30KjqjxWrQERELmMAIiIicgONrf5YsQpEROQaBiAiIqJrrEnVHytWgYiIXMIAREREdI01tfpjxSoQEVHTMQARERFdQy5Vf6xYBSIiajIGICIiomvI1eqPFatARERNwwBERER0jTSr+mPFKhARUZMwABEREV0jza3+WLEKRETUeAxARERE10CLVH+sWAUiImo0rxpBLRMREVEbMe/bgsoj6WrNscvf5KOmwqQtd+oVDq8uRm3ZES/vTjA+tQBe/l1Vi61i7F7yNLJK1GoDAzFk3lKMClarUs5aLFu3Xa04MHgR5sRHqRWgNH0JNnx4GGZTpWoR/EJg7DUCd0z6IWJ6O3/u5A6ykTprAQrUWkPjMWZFEiLVmqZkO5KXrEW5Wm0gOAnx88bD9p8VkTtgBYiIiOga8BvxMLo9t+yKl043hautgS6P/dThNtZL1xmvOgk/beNyRVn98COZi2HK34j038djzXtHYVbNbasSedtfxpqV2+E0/7UA87HNSHnlZextzQchohbBChAREZGbOv/aHFQfz9GWuz23FIb+dRWXplEVIDThF3lVAQpL2IK4ej/7O1by0Vyk7ES9SlJ1RTHy09ch7cMMmC2BGPDTFDxyi35b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BimgRivKWIVtH+xDuRkw9ByBH/xoBob2VDc60PqnwGUjddYCFKi1hhycAleyHclL1taNomcvmKfAkXtiBYiIiIiojYUOm4HEV9/DnBXvYdbcK4cfKfjBpZy4lKiFsAJERETkplquAkRERFasABERERERkcdgACIiIiIiIo/BAERERERERB6DAYiIiIiIiDwGAxAREREREXkMBiAiIiIiIvIYDEBEREREROQxGICIiIiIiMhjMAAREREREZHHYAAiIiIiIiKPwQBEREREREQegwGIiIiIiIg8BgMQERERERF5DAYgIiIiIiLyGAxARERERETkMRiAiIiIiIjIYzAAERERERGRx/CqEdQyERFRqzmx8zUs2/ylWrM1CJMmjcfYsTerdbJV9vMx2nW355bC0D9KWyYiItcxABERUZs48do96D/zU7XmyHCsPL4fzzEH1cMARETUshiAiIjak5LtSF6yFuVyOWIenk2Mwql967B31z6UmioBbyOMfX+I+38yBRHdtHvUU30mG3u3b8SXuUdhNlu3H49hj0/DkB5qIxRj9+KnkXXdbCTOGIEA1eqI+cByvP5uMYbOX4r7au/vWL0ANDwRibfJhX/j38mfojYWDV+J4/ufAzNQHQYgIqKWxT5ARETtVelJpKc8g02bd+nhR7KYYMpfj20rN6NAb6llylmLNUsWIOtIth5+JG37jdi9ZC52n9abgBD06usLfHUURarFmeKio4D/QIReJfzYGz5lDtauXSsu+7H/+EoMV+349EscV4tEREStgQGIiKg9CR6PxBVbMGawWC7ZKMKMCcboFzH11S2YI9qfnTsboUZx29lUZB3T7qEzZ2Pbu9th9h+GqITVeGaZvv2cZe9h6tTxMOIosv6+T68sCcEh4SIcnUTxGdUg5L77OJbNehnp51UDKlFcUgz07CciUzPcPABaMUgaPgj91SLpDP0jtYuXv3xjiYiouRiAiIjaoaBgEVAEv7sWIXFqNEL9tFX49RyBxx4eIZZMKC4s0xuF8gObUVARgoiEeXgosjeMBnWDwReh0UmIezgKOH4IeWa9Oaj3QBhEKCquLSMdRV6OSVwfwnERunT5KPpKPGbv8CueJndFJ05gZ9I4JGsrw5G4gKe/2ev23DLt0ummfqqFiIiagwGIiKgdMnTyFf9/BIY9KoNKfX59B+qBxKJOcxOKCrLF/y9G7qqHsWxWw8u6zfrt5dYSUN8IBIur4oJCff3Yp8ivMMLgD5QeOaRXis4Xo7RChKXQptd/Pp3ZH15eXvDq3x/jZPoZnogdx/dj7Vj9diIiotbCAERE1G51RWdV+bma6uq6MNQofuEI6QGYC/O1sFOQm4Fq/9H4wdhoIF9ViopOitvEdr1lGGumT5Mxrv89SHrthGogIiJqHQxAREQewGDQK0b3qb5Cji9LMUqWfTRqIITTJ1GMQuTmFMMweDiGDh6BIOxD3ueVKC/5BtWIQEhPdZcmGL5yB44fP65fdiSqQRA+RfLM/kjaqa0QERG1CgYgIiIPEBomh0/OEMHF2n/n6rT7VBxF0RfZ+PqsEeG3DwS6RaF/b6DoyGHkydPqet2EULV90/THzTffrF/GrkXKytpx4PDvPFaBiIio9TAAERF5gIC7RiPUuxJFqTOR8tFRlFSoGyyVMJ3JR9bW5ViTkgE1BoImIGwg/HAUX76/A+X+oxFxi2wNxC23iSB0LBUH8yuBnr0RpG1NRETUPjAAERF5Ar9hmPST8fCzFKNk51yk/FoNgDD7MaxZPBO79+yDqfQsiqvV9tKNergxnS3UTn8boLciePAIBFjyRTsQFObqyGTHceLECf2yMwnx1glShdsGcBw4IiJqPQxAREQewhiZhGfmv4iI8HAYfFSjTyCM4ZMwJOEtzHp+PMJsh5RTAyGIe+qnv1kFR6HP9XLBiKBg1+am+XTmOPTv31+/jEtGbfxJ3MGR4IiIqFV51QhqmYiIqNWceO0e9Lep9NQzXM4BlCLCD6s/RETUuhiAiIiIiIjIY/AUOCIiIiIi8hgMQERERERE5DEYgIiIiIiIyGMwABERERERkcdgACIiIiIiIo/BAERERERERB6DAYiIiIiIiDwGAxAREREREXkMToRKROQmLhRkqCUiopbXNWyYWiLybAxARERuQgYgU2GmWiMialkh98xSS0SejafAERERERGRx2AFiIjITcjqj/U0OGOvKO2a6Eq8xP+IruTCqc/VEitARFYMQEREbsI2AHXtdTuMoQxBRNQ8xQffUUsMQERWPAWOiMhN2P4eVSP+R0RERC2PAYiIiIiIiDwGAxAREREREXkMBiAiIiIiIvIYDEBERG7Cy4sjehEREbU2BiAiIjfE4Y2JiIhaBwMQEZEb4ihwRERErYMBiIiIiIiIPAYDEBGRm+C81ERERK2PAYiIiIiIiDwGAxARkZvgKHBEREStjwGIiMgNcRQ4IiKi1sEARETkJmz7AHEUOCIiotbBAERERERERB6DAYiIiIiIiDwGAxAREREREXkMBiAiIjfBUeCIiIhaHwMQEZEb4ihwRERErYMBiIjIDXEUOCIiotbBAERERERERB6DAYiIiIiIiDwGAxAREREREXkMBiAiIiIiIvIYDEBEREREROQxGICIiIiIiMhjMAAREREREZHHYAAiIiIiIiKPwQBEREREREQegwGIiIiIiIg8BgMQERERERF5DAYgIiIiIiLyGAxARERERETkMRiAiIiIiIjIYzAAERERERGRx2AAIiIiIiIij8EAREREREREHoMBiIiIiIiIPIZXjaCWiYjoGjIVZuJCQYa2bOwVBS/xvxrxP0kuS9Z1W7bb2Wrt9sa6Vs/PWXtjXavn56ydyBWmU9lqCQi5Z5ZaIvJsDEBERG7CNgAREbU0BiAiHU+BIyIiIiIij8EKEBGRm5AVIOtHspeXV+2yZF2X15L9dk1pl5pz/yu122vp+1s5ur8t+/bWvr+VK39XLluvrezXrZy1EzWGsXeMWiLybAxARERERETkMXgKHBEREREReQwGICIiIiIi8hgMQERERERE5DEYgIiIiIiIyGMwABERERERkcdgACIiIiIiIg8B/H+KIfv+FBHhQgAAAABJRU5ErkJggg==" alt="p1"></p>
<p>可见，如果<code>B</code>的实例要找某个方法或属性便会沿着他的原型链一直找到父类的原型，从而实现了继承。这跟ES5中实现继承的方法是一致的。只不过ES6将整个过程封装为了语法糖</p>
<h4 id="继承中的构造函数-constructor-及构造函数中的super"><a href="#继承中的构造函数-constructor-及构造函数中的super" class="headerlink" title="继承中的构造函数(constructor)及构造函数中的super"></a>继承中的构造函数(constructor)及构造函数中的super</h4><p>根据规范，如果子类没有 <code>constructor</code>，那么将生成下面这样的包含<code>super(...)</code>的 <code>constructor</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class B extends A &#123;</span><br><span class="line">  constructor(...args) &#123;</span><br><span class="line">    super(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类构造函数中的<code>super(...)</code>表示调用父类的<code>constructor</code>方法（你可以简单的将其理解为<code>super(...) &lt;==&gt; A.prototype.constructor.call(this)</code>,但是这样理解并不准确）。在子类的构造函数中必须先使用<code>super(...)</code>调用父类的构造函数，然后才能使用<code>this</code>，否则创建子类的实例时将报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;&#125;</span><br><span class="line">class B extends A&#123;</span><br><span class="line">  constructor(name)&#123;</span><br><span class="line">    this.name &#x3D; name;&#x2F;&#x2F;ReferenceError: Must call super constructor in derived class before accessing &#39;this&#39; or returning from derived constructor</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let b &#x3D; new B();</span><br><span class="line"></span><br><span class="line">&#x2F;******&#x2F;</span><br><span class="line"></span><br><span class="line">class A&#123;&#125;</span><br><span class="line">class B extends A&#123;</span><br><span class="line">  constructor(name)&#123;</span><br><span class="line">    super();</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let b &#x3D; new B(&#39;德洛丽丝&#39;);</span><br><span class="line">console.log(b.name);&#x2F;&#x2F;德洛丽丝</span><br></pre></td></tr></table></figure>

<blockquote>
<p>作为函数调用使用的<code>super(...)</code>只能用在子类的构造函数之中，用在其他地方就会报错</p>
</blockquote>
<p>如果我们在子类中也显示定义了子类的<code>constructor</code>，那么这就叫做<code>重写constructor</code>(即重写父类的<code>constructor</code>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.speed &#x3D; 0;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Rabbit extends Animal &#123;</span><br><span class="line">  constructor(name, earLength) &#123;</span><br><span class="line">    super(name);</span><br><span class="line">    this.earLength &#x3D; earLength;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let rabbit &#x3D; new Rabbit(&quot;White Rabbit&quot;, 10);</span><br><span class="line">console.log(rabbit.name); &#x2F;&#x2F; White Rabbit</span><br><span class="line">console.log(rabbit.earLength); &#x2F;&#x2F; 10</span><br><span class="line">console.log(rabbit.speed); &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure>

<h4 id="重写方法"><a href="#重写方法" class="headerlink" title="重写方法"></a>重写方法</h4><p>所谓<code>重写方法</code>是指：按照原型链的搜索过程，子父类中有同名方法时，会执行子类中的方法（而不是父类中的方法）。因此，我们可在子类中覆盖父类中的同名方法，这就叫<code>重写方法</code></p>
<p>我们除了能在子类中添加子类自己的方法，还能在子类中重写父类中的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.speed &#x3D; 0;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run(speed) &#123;</span><br><span class="line">    this.speed &#x3D; speed;</span><br><span class="line">    console.log(&#96;$&#123;this.name&#125; runs with speed $&#123;this.speed&#125;.&#96;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stop() &#123;</span><br><span class="line">    this.speed &#x3D; 0;</span><br><span class="line">    console.log(&#96;$&#123;this.name&#125; stands still.&#96;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Rabbit extends Animal &#123;</span><br><span class="line">  hide() &#123;</span><br><span class="line">    console.log(&#96;$&#123;this.name&#125; hides!&#96;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stop() &#123;</span><br><span class="line">    console.log(&#39;我是子类的stop&#39;);</span><br><span class="line">    this.hide();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let rabbit &#x3D; new Rabbit(&quot;White Rabbit&quot;);</span><br><span class="line"></span><br><span class="line">rabbit.run(5); &#x2F;&#x2F; White Rabbit runs with speed 5.</span><br><span class="line"></span><br><span class="line">rabbit.stop();</span><br><span class="line">&#x2F;&#x2F; 我是子类的stop     </span><br><span class="line">&#x2F;&#x2F; White Rabbit hides!</span><br></pre></td></tr></table></figure>

<p>上述代码中，子类重写了父类中的<code>stop</code>方法</p>
<h4 id="重写属性"><a href="#重写属性" class="headerlink" title="重写属性"></a>重写属性</h4><p>除了重写方法，子类还能重写父类的同名属性</p>
<p>但是，在重写属性时会有一个诡异的行为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  name &#x3D; &#39;animal&#39;;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    alert(this.name); &#x2F;&#x2F; (*)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Rabbit extends Animal &#123;</span><br><span class="line">  name &#x3D; &#39;rabbit&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new Animal(); &#x2F;&#x2F; animal</span><br><span class="line">new Rabbit(); &#x2F;&#x2F; animal</span><br><span class="line"></span><br><span class="line">&#x2F;******&#x2F;</span><br><span class="line"></span><br><span class="line">class Animal &#123;</span><br><span class="line">  showName() &#123;  &#x2F;&#x2F; 而不是 this.name &#x3D; &#39;animal&#39;</span><br><span class="line">    alert(&#39;animal&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.showName(); &#x2F;&#x2F; 而不是 alert(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Rabbit extends Animal &#123;</span><br><span class="line">  showName() &#123;</span><br><span class="line">    alert(&#39;rabbit&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new Animal(); &#x2F;&#x2F; animal</span><br><span class="line">new Rabbit(); &#x2F;&#x2F; rabbit</span><br></pre></td></tr></table></figure>

<p>在上述第一块代码中的<code>*</code>处，我们理想应该输出<code>rabbit</code>,但是输出的却是父类中的<code>name</code>。但是当使用同名方法时（第二块代码），却能如我们所愿！为什么呢？</p>
<p>实际上，原因在于属性初始化的顺序。类属性是这样初始化的：</p>
<ul>
<li>对于基类（还未继承任何东西的那种），在构造函数调用前初始化。</li>
<li>对于派生类，在 <code>super()</code> 后立刻初始化</li>
</ul>
<p>所以，<code>new Rabbit()</code> 调用了 <code>super()</code>，因此它执行了父类构造器，并且（根据派生类规则）只有在此之后，它的类属性才被初始化。在父类构造器被执行的时候，<code>Rabbit</code> 还没有自己的类属性，这就是为什么 <code>Animal</code> 类属性被使用了（会搜索原型链找到父类的<code>name</code>属性）</p>
<p>因此，对于子类而言：在子类的构造函数中的<code>super(...)</code>执行完毕前使用子类中的属性是不可能的</p>
<h3 id="super与this"><a href="#super与this" class="headerlink" title="super与this"></a>super与this</h3><p>接下来我们讨论<code>super</code>的相关内容。虽然前面已经有所涉及，但还有很多<code>super</code>的特性并未提及，在此节我们将对此做一个系统梳理</p>
<p><code>super</code>关键字有三种用法：</p>
<ul>
<li>通过<code>super.方法名(...)</code>来调用一个父类方法</li>
<li>在子类的构造函数中通过<code>super(...)</code>调用父类的<code>constructor</code></li>
<li>在普通<code>&#123;&#125;</code>对象的方法中也可以使用<code>super</code>关键字</li>
</ul>
<p>上述前面两种都与类相关，最后一种与普通对象相关。下面我们分为两类来讨论<code>super</code></p>
<h4 id="super在普通对象的方法中的使用"><a href="#super在普通对象的方法中的使用" class="headerlink" title="super在普通对象的方法中的使用"></a>super在普通对象的方法中的使用</h4><p>此时，<code>super</code>指向它所在对象的原型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const proto &#x3D; &#123;</span><br><span class="line">  foo: &#39;hello&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  foo: &#39;world&#39;,</span><br><span class="line">  find() &#123;</span><br><span class="line">    return super.foo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.setPrototypeOf(obj, proto);</span><br><span class="line">obj.find() &#x2F;&#x2F; &quot;hello&quot;</span><br></pre></td></tr></table></figure>

<p>如果使用<code>super</code>调用它所在对象的原型中的方法，那么原型方法中的<code>this</code>指向的是<code>super</code>所在对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const proto &#x3D; &#123;</span><br><span class="line">  x: &#39;hello&#39;,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    console.log(this.x);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  x: &#39;world&#39;,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    super.foo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.setPrototypeOf(obj, proto);</span><br><span class="line"></span><br><span class="line">obj.foo() &#x2F;&#x2F; &quot;world&quot;  不是hello</span><br></pre></td></tr></table></figure>

<p>需要特别注意的是：<code>super</code>只能用在对象方法的简写形式中（即不是<code>方法名:function()&#123;...&#125;</code>形式定义的方法中，详见“对象的扩展”一章）</p>
<h4 id="super在类中的使用"><a href="#super在类中的使用" class="headerlink" title="super在类中的使用"></a>super在类中的使用</h4><ul>
<li><code>super</code>作为对象时，在普通方法中，指向父类的原型对象(即<code>class 类名&#123;...&#125;</code>中的<code>&#123;...&#125;</code>)；在静态方法中，指向父类(即类名所代表的函数)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">  static test1()&#123;</span><br><span class="line">    console.log(&#39;A的静态方法test1&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">  test1()&#123;</span><br><span class="line">    console.log(&#39;A的公共方法test1&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A&#123;</span><br><span class="line">  static test1()&#123;</span><br><span class="line">    super.test1();</span><br><span class="line">  &#125;</span><br><span class="line">  test2()&#123;</span><br><span class="line">    super.test1();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b &#x3D; new B();</span><br><span class="line">b.test2();&#x2F;&#x2F;A的公共方法test1</span><br><span class="line">B.test1();&#x2F;&#x2F;A的静态方法test1</span><br></pre></td></tr></table></figure>

<ul>
<li>ES6 规定，在子类普通方法中通过<code>super</code>调用父类的方法时，父类方法内部的<code>this</code>指向当前的子类实例。在子类的静态方法中通过<code>super</code>调用父类的方法时，父类方法内部的<code>this</code>指向当前的子类，而不是子类的实例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.x &#x3D; 1;</span><br><span class="line">  &#125;</span><br><span class="line">  print() &#123;</span><br><span class="line">    console.log(this.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.x &#x3D; 2;</span><br><span class="line">  &#125;</span><br><span class="line">  m() &#123;</span><br><span class="line">    super.print();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b &#x3D; new B();</span><br><span class="line">b.m() &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">&#x2F;******&#x2F;</span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.x &#x3D; 1;</span><br><span class="line">  &#125;</span><br><span class="line">  static print() &#123;</span><br><span class="line">    console.log(this.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.x &#x3D; 2;</span><br><span class="line">  &#125;</span><br><span class="line">  static m() &#123;</span><br><span class="line">    super.print();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.x &#x3D; 3;</span><br><span class="line">B.m() &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>

<p>注意，使用super的时候，必须显式指定是作为函数（即<code>super(...)</code>的形式使用<code>super</code>）、还是作为对象使用（即<code>super.属性/方法</code>的形式使用<code>super</code>），否则会报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    console.log(super); &#x2F;&#x2F; 报错</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianghui-ma.github.io/2021/08/08/(11)%20Promise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/img/header.png">
      <meta itemprop="name" content="small_ma">
      <meta itemprop="description" content="慢慢来，比较快！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Execute">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/08/(11)%20Promise/" class="post-title-link" itemprop="url">(11) Promise</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-08 15:07:20" itemprop="dateCreated datePublished" datetime="2021-08-08T15:07:20+08:00">2021-08-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-26 21:28:52" itemprop="dateModified" datetime="2021-06-26T21:28:52+08:00">2021-06-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ES6/" itemprop="url" rel="index"><span itemprop="name">ES6</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="11-Promise"><a href="#11-Promise" class="headerlink" title="(11) Promise"></a>(11) Promise</h1><h3 id="Promise的基本概念"><a href="#Promise的基本概念" class="headerlink" title="Promise的基本概念"></a>Promise的基本概念</h3><h4 id="为什么会有Promise"><a href="#为什么会有Promise" class="headerlink" title="为什么会有Promise"></a>为什么会有Promise</h4><p>Promise是异步编程的一种解决方案，主要是为了解决异步编程时的回调地狱问题。通过Promise，便可以将回调地狱变为线性的操作（具体看下面的案例）</p>
<p>ES6将Promise写入了语言规范，并提供了<code>Promise</code>对象</p>
<h4 id="Promise实例的状态"><a href="#Promise实例的状态" class="headerlink" title="Promise实例的状态"></a>Promise实例的状态</h4><p><code>Promise</code>实例有三种状态：</p>
<ul>
<li><code>pending</code>：进行中</li>
<li><code>fulfilled</code>：成功。有时我们也将<code>fulfilled</code>称为<code>resolved</code>（本文后面都将采用这种称呼）</li>
<li><code>rejected</code>：失败</li>
</ul>
<p><code>Promise</code>实例的状态改变只有两种可能：</p>
<ul>
<li>从<code>pending</code>变为<code>resolved</code>（异步操作成功时的状态变化）</li>
<li>从<code>pending</code>变为<code>rejected</code>（异步操作失败时的状态变化）</li>
</ul>
<p>一旦状态变为<code>resolved/rejected</code>，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 <code>settled</code>（已定型）。<strong>如果一个<code>Promise</code>实例的状态已定型，那么你再为实例注册状态改变时的回调函数，那么与实例当前状态所对应的回调函数会立即执行</strong>（加粗部分对理解后面链式调用时的执行流程十分重要）</p>
<h3 id="Promise的用法"><a href="#Promise的用法" class="headerlink" title="Promise的用法"></a>Promise的用法</h3><p>在使用Promise时，首先要通过<code>Promise</code>构造函数创建一个<code>Promise</code>实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const promise &#x3D; new Promise(function(resolve, reject) &#123; &#x2F;&#x2F;异步代码(比如网络请求等) &#125;);</span><br></pre></td></tr></table></figure>

<p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>（参数名是任意的，这儿只是为了专业点）。它们是两个函数，由 <code>JavaScript</code> 引擎提供，不用自己部署，使用时直接调用就行(如<code>resolve(...)</code>)</p>
<p><code>resolve</code>(<code>reject</code>)函数的作用有二：一是，将<code>Promise</code>实例的状态从<code>pending</code>变为<code>resolved</code>(<code>rejected</code>)；二是，这两个函数都接受一个参数，通过参数将异步任务的结果传给在<code>then</code>中注册的状态改变时的回调函数（见下面的<code>then</code>方法）</p>
<p>除了调用<code>resolve/reject</code>会改变<code>Promise</code>实例的状态以外。前面<code>//异步代码(比如网络请求等)</code>中如果抛出了错误，那么<code>Promise</code>状态会变为<code>rejected</code>。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve(123);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then((value) &#x3D;&gt; &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    throw new Error(&#39;test&#39;);&#x2F;&#x2F;手动抛错</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, (reason) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(reason + &#39;--&#39;);</span><br><span class="line">&#125;).then(value &#x3D;&gt; &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;, reason &#x3D;&gt; &#123;</span><br><span class="line">  console.log(reason + &#39;++&#39;);&#x2F;&#x2F;Error: test++</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;********************&#x2F;</span><br><span class="line"></span><br><span class="line">let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  let y &#x3D; x + 1;&#x2F;&#x2F;x未定义，抛出错误</span><br><span class="line">&#125;);</span><br><span class="line">promise.then((value) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;ok&#39; + value);</span><br><span class="line">&#125;, (reason) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(reason + &#39;--&#39;);&#x2F;&#x2F;ReferenceError: x is not defined--</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面阐述了如何创建<code>Promise</code>实例，下面讲述<code>Promise</code>实例的方法：</p>
<blockquote>
<p>所有<code>Promise</code>实例方法的返回值都是<code>Promise</code>实例，因此可以链式调用这些实例方法。<strong>同时要重点注意各个实例方法所返回的<code>Promise</code>实例的状态（MDN中有详细说明），这样才能理解好链式调用的执行流程</strong></p>
</blockquote>
<p>1、<code>then(resolveCallback, rejectCallback)</code></p>
<p><code>then</code>方法的作用是为 <code>Promise</code> 实例添加状态改变时的回调函数。<code>then</code>方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数是<code>rejected</code>状态的回调函数，它们都是可选的。两个回调函数都接受一个参数，该参数就是创建<code>Promise</code>实例时，<code>resolve/reject(...)</code>传过来的参数</p>
<p><code>then</code>方法返回的<code>Promise</code>实例的状态有六种情况，具体参见**<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then#return_value">MDN-Return value</a>**（非常重要）</p>
<blockquote>
<p>重点注意：当我们在<code>then</code>的回调函数中手动返回一个<code>Promise</code>对象时，<code>then</code>返回的并不是我们手动返回的那个<code>Promise</code>对象，而依然是<code>then</code>自己的<code>Promise</code>对象，只不过此时<code>then</code>返回的<code>Promise</code>对象的状态由我们手动返回的<code>Promise</code>对象的状态决定（可以看上面链接中的最后一个情况，里面有说明）。实际上，<code>then</code>永远返回的都是自己的<code>Promise</code>对象（即使我们手动返回了<code>Promise</code>对象），不仅仅<code>then</code>，后面的实例方法都是如此</p>
</blockquote>
<p>下面我们演示通过<code>Promise</code>解决回调地狱的例子（不用在意例子中使用的还未学习的技术，注重看<code>Promise</code>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 例子描述：</span><br><span class="line">&#x2F;&#x2F; 使用Nodejs的fs模块异步读取md文件中的字符串内容，然后打印</span><br><span class="line">const fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line">const &#123; rejects &#125; &#x3D; require(&#39;node:assert&#39;);</span><br><span class="line">const &#123; resolve &#125; &#x3D; require(&#39;node:path&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 回调地狱写法</span><br><span class="line">fs.readFile(&#39;.&#x2F;resources&#x2F;为学.md&#39;, (err, data1) &#x3D;&gt; &#123;</span><br><span class="line">  fs.readFile(&#39;.&#x2F;resources&#x2F;插秧诗.md&#39;, (err, data2) &#x3D;&gt; &#123;</span><br><span class="line">    fs.readFile(&#39;.&#x2F;resources&#x2F;观书有感.md&#39;, (err, data3) &#x3D;&gt; &#123;</span><br><span class="line">      let result &#x3D; data1 + data2 + data3;</span><br><span class="line">      console.log(result);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Promise写法</span><br><span class="line">const p &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  fs.readFile(&#39;.&#x2F;resources&#x2F;为学.md&#39;, (err, data) &#x3D;&gt; &#123;</span><br><span class="line">    resolve(data);&#x2F;&#x2F;读取成功后将结果传给then中注册的resolveCallback回调函数</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then((value) &#x3D;&gt; &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    fs.readFile(&#39;.&#x2F;resources&#x2F;插秧诗.md&#39;, (err, data) &#x3D;&gt; &#123;</span><br><span class="line">      resolve([data, value]);&#x2F;&#x2F;读取成功后将结果传给then中注册的resolveCallback回调函数</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).then((value) &#x3D;&gt; &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    fs.readFile(&#39;.&#x2F;resources&#x2F;观书有感.md&#39;, (err, data) &#x3D;&gt; &#123;</span><br><span class="line">      resolve(value.push(data));&#x2F;&#x2F;读取成功后将结果传给then中注册的resolveCallback回调函数</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).then((value) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(value[0] + value[1] + value[2]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上例中只在<code>then</code>中注册了<code>resolved</code>状态的回调，没有注册<code>rejected</code>状态的回调。可见，将回调地狱变为了类似于同步编程的线性操作</p>
<p>2、<code>catch(rejectCallback)</code></p>
<p><code>catch</code>方法的作用也是为 <code>Promise</code> 实例添加状态改变时的回调函数，但是<code>catch</code>只处理<code>rejected</code>状态的<code>Promise</code>实例。而且官方建议使用<code>catch</code>来代替<code>then</code>中的<code>rejectCallback</code>回调函数，使<code>then</code>专门处理<code>resolved</code>状态的<code>Promise</code>实例，这样更加规范</p>
<p><code>catch</code>返回的<code>Promise</code>实例的状态见**<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch#parameters">Parameters</a>**部分的最后一句话</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;&#x2F;&#x2F;promise为第1个Promise实例</span><br><span class="line">  reject(&#39;失败&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(value &#x3D;&gt; &#123;&#x2F;&#x2F;then返回第2个Promise实例</span><br><span class="line">  console.log(&#39;成功&#39;);</span><br><span class="line">&#125;).catch(reason &#x3D;&gt; &#123;</span><br><span class="line">  console.log(reason);&#x2F;&#x2F;失败</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这儿你可能十分费解上述链式调用的执行流程。下面我便为例详细阐述：</p>
<blockquote>
<p><code>then</code>实例方法还有一个非常重要的特性就是：假如有<code>Promise实例.then(...)</code>，那么如果<code>Promise实例</code>处于<code>rejected/resolved</code>状态，但是<code>then</code>方法没有处理上述状态的状态改变回调函数，那么此时<code>then</code>返回的<code>Promise</code>实例与<code>Promise实例</code>的状态一致</p>
</blockquote>
<p>第1个<code>Promise</code>实例为<code>rejected</code>状态，但是<code>then</code>没有处理该状态的<code>rejectCallback</code>状态改变回调函数，所以<code>then</code>返回的第2个<code>Promise</code>实例依然为<code>rejected</code>状态，然后<code>catch</code>处理了该状态（此处<code>catch</code>还会返回一个<code>resolved</code>状态的<code>Promise</code>实例，只是后面没有链式调用处理了）</p>
<p>如果<code>Promise</code>实例不是<code>rejected</code>状态，则会跳过<code>catch</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;&#x2F;&#x2F;promise为第1个Promise实例</span><br><span class="line">  resolve(&#39;成功&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.catch(reason &#x3D;&gt; &#123;</span><br><span class="line">  console.log(reason);</span><br><span class="line">&#125;).then(value &#x3D;&gt; &#123;</span><br><span class="line">  console.log(value);&#x2F;&#x2F;成功</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>3、<code>finally(onFinally)</code></p>
<p><code>finally()</code>方法用于指定不管 <code>Promise</code> 对象最后状态如何，都会执行的操作。<code>onFinally</code>是一个函数，该函数不接受任何参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.then(result &#x3D;&gt; &#123;···&#125;)</span><br><span class="line">.catch(error &#x3D;&gt; &#123;···&#125;)</span><br><span class="line">.finally(() &#x3D;&gt; &#123;···&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数</p>
<p>至此，<code>Promise</code>实例的方法介绍完毕。为了更深刻地理解链式调用的执行流程，我们举一个综合性的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;&#x2F;&#x2F;promise为第1个Promise实例</span><br><span class="line">  reject(&#39;失败&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then((value) &#x3D;&gt; &#123;&#x2F;&#x2F;then返回第2个Promise实例</span><br><span class="line">  console.log(&#39;ok&#39; + value);</span><br><span class="line">&#125;, (reason) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(reason + &#39;--&#39;);</span><br><span class="line">&#125;).then(value &#x3D;&gt; &#123;&#x2F;&#x2F;then返回第3个Promise实例</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    reject(&#39;再次失败&#39;);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).catch((reason) &#x3D;&gt; &#123;&#x2F;&#x2F;catch返回第4个Promise实例</span><br><span class="line">  console.log(&#39;no1&#39; + reason);</span><br><span class="line">&#125;).then(value &#x3D;&gt; &#123;&#x2F;&#x2F;then返回第5个Promise实例，但后面没有链式调用进行处理了</span><br><span class="line">  console.log(&#39;HK416&#39;);</span><br><span class="line">&#125;).finally(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;结束了&#39;);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 失败--</span><br><span class="line">&#x2F;&#x2F; no1再次失败</span><br><span class="line">&#x2F;&#x2F; HK416      </span><br><span class="line">&#x2F;&#x2F; 结束了</span><br></pre></td></tr></table></figure>

<p>第1个<code>Promise</code>实例为<code>rejected</code>状态，故执行后面<code>then</code>中的<code>rejectCallback</code>回调；第2个<code>Promise</code>实例为<code>resolved</code>状态（见前面“<code>then</code>方法返回的<code>Promise</code>实例的状态有六种情况”），故执行后面<code>then</code>中的<code>resolveCallback</code>回调；第3个<code>Promise</code>实例为<code>rejected</code>状态，故执行后面<code>catch</code>中的<code>rejectCallback</code>回调；第4个<code>Promise</code>实例为<code>resolved</code>状态，故执行后面<code>then</code>中的<code>resolveCallback</code>回调；第5个<code>Promise</code>实例为<code>resolved</code>状态，无论如何都会执行<code>onFinally</code></p>
<p>所以，判断链式调用的执行流程很简单——基于每次返回的<code>Peomise</code>实例的状态判断就行</p>
<h3 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h3><p>1、如何中断<code>Promise</code>链？</p>
<p>在实战时遇见了这样一种情况：在链式处理<code>Promsie</code>的过程中，在链的某个位置已经得出结果后便不需要再执行后续的链式处理了。此时我们就需要用到中断<code>Promise</code>链</p>
<p>中断方法是：当返回一个<code>pending</code>状态的<code>Promise</code>时，便会中断Promise链的执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve()</span><br><span class="line">     .then(() &#x3D;&gt; &#123;</span><br><span class="line">         console.log(&#39;[onFulfilled_1]&#39;);</span><br><span class="line">         return new Promise(()&#x3D;&gt;&#123;&#125;); &#x2F;&#x2F; 返回“pending”状态的Promise对象</span><br><span class="line">     &#125;)</span><br><span class="line">     .then(() &#x3D;&gt; &#123;                   &#x2F;&#x2F; 后续的函数不会被调用</span><br><span class="line">         console.log(&#39;[onFulfilled_2]&#39;);</span><br><span class="line">     &#125;)</span><br><span class="line">     .catch(err &#x3D;&gt; &#123;</span><br><span class="line">         console.log(&#39;[catch]&#39;, err);</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure>





      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianghui-ma.github.io/2021/08/08/(10)%20Proxy%E4%B8%8EReflect/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/img/header.png">
      <meta itemprop="name" content="small_ma">
      <meta itemprop="description" content="慢慢来，比较快！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Execute">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/08/(10)%20Proxy%E4%B8%8EReflect/" class="post-title-link" itemprop="url">(10) Proxy与Reflect</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-08 15:07:20" itemprop="dateCreated datePublished" datetime="2021-08-08T15:07:20+08:00">2021-08-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-09 16:51:28" itemprop="dateModified" datetime="2021-04-09T16:51:28+08:00">2021-04-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ES6/" itemprop="url" rel="index"><span itemprop="name">ES6</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="10-Proxy-代理-与Reflect-反射"><a href="#10-Proxy-代理-与Reflect-反射" class="headerlink" title="(10) Proxy(代理)与Reflect(反射)"></a>(10) Proxy(代理)与Reflect(反射)</h1><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><h4 id="什么是Proxy"><a href="#什么是Proxy" class="headerlink" title="什么是Proxy"></a>什么是Proxy</h4><p>Proxy主要用于对象，用于修改对象操作(如读取/添加/删除对象属性)的默认行为。Proxy 可以理解成，在被代理对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写</p>
<blockquote>
<p>Proxy属于“元编程”，即对编程语言进行编程。说得再通俗易懂写就是——修改语言原始定义的默认行为，以按照自己的意愿进行个性化设置</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var proxy &#x3D; new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  get: function(target, propKey) &#123;</span><br><span class="line">    return 35;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.time &#x2F;&#x2F; 35</span><br><span class="line">proxy.name &#x2F;&#x2F; 35</span><br><span class="line">proxy.title &#x2F;&#x2F; 35</span><br></pre></td></tr></table></figure>

<p>上述代码中，为一个空对象设置了代理，并在代理中更改了获取属性操作(即<code>.</code>)的行为，所以后面获取属性值的操作都会被该代理拦截，从而按照你的设置返回<code>35</code></p>
<h4 id="Proxy的使用"><a href="#Proxy的使用" class="headerlink" title="Proxy的使用"></a>Proxy的使用</h4><p>1、首先要创建代理对象</p>
<p>ES6 原生提供 <code>Proxy</code> 构造函数，用来生成 Proxy 实例</p>
<p><code>var proxy = new Proxy(target, handler);</code></p>
<ul>
<li><code>target</code>为被代理的对象</li>
<li><code>handler</code>也是一个对象，用来定制拦截行为</li>
</ul>
<p>下面是<code>Proxy</code>支持的可以定制的拦截行为：</p>
<ol>
<li><code>get(target, propKey, receiver)</code>：拦截对象属性的读取，比如<code>proxy.foo</code>和<code>proxy[&#39;foo&#39;]</code></li>
<li><code>set(target, propKey, value, receiver)</code>：拦截对象属性的设置，比如<code>proxy.foo = v</code>或<code>proxy[&#39;foo&#39;] = v</code></li>
<li>其他行为可查阅资料，不再一一赘述</li>
</ol>
<p><code>get/set</code>方法的参数<code>target, propKey, receiver</code>分别表示<code>被代理的对象, 你所读取的属性名, 代理实例本身</code>。<code>set</code>的<code>value</code>参数表示<code>你设置的属性值</code></p>
<p>2、使用 Proxy 实例操作对象</p>
<p>Proxy 实例创建完毕后，应用Proxy实例操作对象，而不能还是由原对象操作自身，否则你定制的拦截行为不会生效</p>
<p>下面给出一个完整的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let obj &#x3D; &#123;</span><br><span class="line">  name : &#39;黑尔&#39;</span><br><span class="line">&#125;;</span><br><span class="line">let proxy &#x3D; new Proxy(obj, &#123;</span><br><span class="line">  get(target, propKey, receiver)&#123;</span><br><span class="line">      console.log(&#39;正在获取属性值...&#39;);</span><br><span class="line">      return target[propKey];</span><br><span class="line">  &#125;,</span><br><span class="line">  set(target, propKey, value, receiver)&#123;</span><br><span class="line">    console.log(&#96;$&#123;propKey&#125;的值更新了...&#96;);</span><br><span class="line">    target[propKey] &#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">proxy.name &#x3D; &#39;伯纳德&#39;;</span><br><span class="line">&#x2F;&#x2F;name的值更新了...</span><br><span class="line"></span><br><span class="line">console.log(proxy.name);</span><br><span class="line">&#x2F;&#x2F; 正在获取属性值...</span><br><span class="line">&#x2F;&#x2F; 伯纳德</span><br></pre></td></tr></table></figure>

<p>在使用<code>Proxy</code>时需要注意：</p>
<ol>
<li><code>Proxy</code>的兼容性不好，有的环境并没实现。由于它不属于语法糖，而是实实在在的新增内容，所以不能通过babel转换为ES5</li>
<li>严格模式下，<code>set</code>代理必须返回<code>true</code>，否则报错</li>
<li>如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则通过 Proxy 对象访问该属性会报错</li>
</ol>
<h4 id="可取消的-Proxy-实例"><a href="#可取消的-Proxy-实例" class="headerlink" title="可取消的 Proxy 实例"></a>可取消的 Proxy 实例</h4><p>ES6还提供了<code>Proxy.revocable()</code>方法，以返回一个可取消的 Proxy 实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let target &#x3D; &#123;&#125;;</span><br><span class="line">let handler &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">let &#123;proxy, revoke&#125; &#x3D; Proxy.revocable(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.foo &#x3D; 123;</span><br><span class="line">proxy.foo &#x2F;&#x2F; 123</span><br><span class="line"></span><br><span class="line">revoke();</span><br><span class="line">proxy.foo &#x2F;&#x2F; TypeError: Revoked</span><br></pre></td></tr></table></figure>

<p><code>Proxy.revocable()</code>方法返回一个对象，该对象的<code>proxy</code>属性是<code>Proxy</code>实例，<code>revoke</code>属性是一个函数，可以取消<code>Proxy</code>实例。上面代码中，当执行<code>revoke</code>函数之后，再访问<code>Proxy</code>实例，就会抛出一个错误</p>
<h4 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h4><p>1、在 Proxy 代理的情况下，通过Proxy实例访问被代理对象的方法时，方法内部的<code>this</code>关键字会指向 Proxy 代理实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const target &#x3D; &#123;</span><br><span class="line">  m: function () &#123;</span><br><span class="line">    console.log(this &#x3D;&#x3D;&#x3D; proxy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const handler &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">const proxy &#x3D; new Proxy(target, handler);</span><br><span class="line"></span><br><span class="line">target.m() &#x2F;&#x2F; false</span><br><span class="line">proxy.m()  &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>2、Proxy 拦截函数内部的<code>this</code>，指向的是<code>handler</code>对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const handler &#x3D; &#123;</span><br><span class="line">  get: function (target, key, receiver) &#123;</span><br><span class="line">    console.log(this &#x3D;&#x3D;&#x3D; handler);</span><br><span class="line">    return &#39;Hello, &#39; + key;</span><br><span class="line">  &#125;,</span><br><span class="line">  set: function (target, key, value) &#123;</span><br><span class="line">    console.log(this &#x3D;&#x3D;&#x3D; handler);</span><br><span class="line">    target[key] &#x3D; value;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const proxy &#x3D; new Proxy(&#123;&#125;, handler);</span><br><span class="line"></span><br><span class="line">proxy.foo</span><br><span class="line">&#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F; Hello, foo</span><br><span class="line"></span><br><span class="line">proxy.foo &#x3D; 1</span><br><span class="line">&#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><p><code>Reflect</code>对象的设计目的有这样几个</p>
<ul>
<li><code>Reflect</code>对象所提供的大部分方法与<code>Object</code>中的同名方法作用相同。因此你可以将<code>Reflect</code>中的方法等同于<code>Object</code>中的方法，以后便可以用<code>Reflect</code>中的方法来替换<code>Object</code>中的同名方法（这也是规范所期望的）。同时，<code>Reflect</code>中的方法规范了<code>Object</code>中同名方法的行为</li>
<li>与<code>Proxy</code>配合使用。由于<code>Reflect</code>中的方法的行为就是语言所定义的默认行为，所以如果<code>Proxy</code>的拦截函数中需要用默认行为操作对象时，便可使用<code>Reflect</code>中的方法</li>
</ul>
<p>对于<code>Reflect</code>对象的设计目的更为详细的叙述建议参见**<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/reflect#%E6%A6%82%E8%BF%B0">Reflect概述</a>**</p>
<p>我们对上面“2、使用 Proxy 实例操作对象”中的代码用<code>Reflect</code>进行优化，这样更合理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let obj &#x3D; &#123;</span><br><span class="line">  name : &#39;黑尔&#39;</span><br><span class="line">&#125;;</span><br><span class="line">let proxy &#x3D; new Proxy(obj, &#123;</span><br><span class="line">  get(target, propKey, receiver)&#123;</span><br><span class="line">      console.log(&#39;正在获取属性值...&#39;);</span><br><span class="line">      return Reflect.get(target, propKey, receiver);&#x2F;&#x2F;使用Reflect执行对对象的默认操作</span><br><span class="line">  &#125;,</span><br><span class="line">  set(target, propKey, value, receiver)&#123;</span><br><span class="line">    console.log(&#96;$&#123;propKey&#125;的值更新了...&#96;);</span><br><span class="line">    Reflect.set(target, propKey, value, receiver);&#x2F;&#x2F;使用Reflect执行对对象的默认操作</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">proxy.name &#x3D; &#39;伯纳德&#39;;</span><br><span class="line">&#x2F;&#x2F;name的值更新了...</span><br><span class="line"></span><br><span class="line">console.log(proxy.name);</span><br><span class="line">&#x2F;&#x2F; 正在获取属性值...</span><br><span class="line">&#x2F;&#x2F; 伯纳德</span><br></pre></td></tr></table></figure>

<p>对Reflect中的方法不在此作一一阐述，使用时可查阅**<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/reflect#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">Reflect静态方法</a>**</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianghui-ma.github.io/2021/08/08/(9)%20Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/img/header.png">
      <meta itemprop="name" content="small_ma">
      <meta itemprop="description" content="慢慢来，比较快！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Execute">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/08/(9)%20Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">(9) Set和Map数据结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-08 15:07:20" itemprop="dateCreated datePublished" datetime="2021-08-08T15:07:20+08:00">2021-08-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-08 17:29:08" itemprop="dateModified" datetime="2021-04-08T17:29:08+08:00">2021-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ES6/" itemprop="url" rel="index"><span itemprop="name">ES6</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="9-Set和Map数据结构"><a href="#9-Set和Map数据结构" class="headerlink" title="(9) Set和Map数据结构"></a>(9) Set和Map数据结构</h1><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="Set的基本使用"><a href="#Set的基本使用" class="headerlink" title="Set的基本使用"></a>Set的基本使用</h4><p><code>Set</code>是一个没有重复值的集合</p>
<blockquote>
<p><code>Set</code>通过类似于<code>===</code>的算法来判断是否有元素重复。但是<code>Set</code>认为<code>NaN</code>与<code>NaN</code>是重复的</p>
</blockquote>
<p>我们可通过<code>Set</code>构造函数来创建一个<code>Set</code>集合。并通过<code>add</code>方法向<code>Set</code>集合中添加数据。还可通过实例的<code>size</code>属性查看<code>Set</code>集合中数据的个数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let set &#x3D; new Set();</span><br><span class="line">set.add(11);</span><br><span class="line">set.add(11);</span><br><span class="line">set.add(&#39;hello&#39;);</span><br><span class="line">set.add([1, 2]);</span><br><span class="line">console.log(set);&#x2F;&#x2F;Set(3) &#123; 11, &#39;hello&#39;, [ 1, 2 ] &#125;&#x2F;&#x2F;并没重复添加11</span><br><span class="line">console.log(set.size);&#x2F;&#x2F;3</span><br></pre></td></tr></table></figure>

<p><code>Set</code>构造函数也可以接受一个拥有迭代器接口的数据结构作为参数，同来初始化<code>Set</code>集合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let set &#x3D; new Set([1, 2]);</span><br><span class="line">console.log(set);&#x2F;&#x2F;Set(2) &#123; 1, 2 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Set实例的方法"><a href="#Set实例的方法" class="headerlink" title="Set实例的方法"></a>Set实例的方法</h4><p>1、操作方法</p>
<p><code>add(value)</code>：见上面<br><code>delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。<br><code>has(value)</code>：返回一个布尔值，表示该值是否为Set的成员。<br><code>clear()</code>：清除所有成员，没有返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s.add(1).add(2).add(2);</span><br><span class="line">&#x2F;&#x2F; 注意2被加入了两次</span><br><span class="line"></span><br><span class="line">s.has(1) &#x2F;&#x2F; true</span><br><span class="line">s.has(2) &#x2F;&#x2F; true</span><br><span class="line">s.has(3) &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">s.delete(2);</span><br><span class="line">s.has(2) &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>2、遍历方法</p>
<ul>
<li><code>keys()</code>：返回键名的遍历器</li>
<li><code>values()</code>：返回键值的遍历器</li>
<li><code>entries()</code>：返回键值对的遍历器</li>
</ul>
<p>与对象的这些方法不同，Set中上述方法返回的是遍历器而不是数组。我们可以用<code>for...of...</code>来遍历返回的遍历器</p>
<p>Set的遍历顺序与元素的添加顺序一致</p>
<p>由于Set没有键名，只有元素。所以<code>keys</code>与<code>values</code>方法的行为一致，都返回元素本身</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">let set &#x3D; new Set([&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]);</span><br><span class="line"></span><br><span class="line">for (let item of set.keys()) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; red</span><br><span class="line">&#x2F;&#x2F; green</span><br><span class="line">&#x2F;&#x2F; blue</span><br><span class="line"></span><br><span class="line">for (let item of set.values()) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; red</span><br><span class="line">&#x2F;&#x2F; green</span><br><span class="line">&#x2F;&#x2F; blue</span><br><span class="line"></span><br><span class="line">for (let item of set) &#123;&#x2F;&#x2F;也可直接for...of...  Set</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; red</span><br><span class="line">&#x2F;&#x2F; green</span><br><span class="line">&#x2F;&#x2F; blue</span><br><span class="line"></span><br><span class="line">for (let item of set.entries()) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; [&quot;red&quot;, &quot;red&quot;]</span><br><span class="line">&#x2F;&#x2F; [&quot;green&quot;, &quot;green&quot;]</span><br><span class="line">&#x2F;&#x2F; [&quot;blue&quot;, &quot;blue&quot;]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>forEach()</code>：使用回调函数遍历每个成员</li>
</ul>
<p>与数组的<code>forEach</code>一样，用于对每个成员执行某种操作，没有返回值。可传入第二个参数以绑定处理函数中的<code>this</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let set &#x3D; new Set([1, 4, 9]);</span><br><span class="line">set.forEach((value, key) &#x3D;&gt; console.log(key + &#39; : &#39; + value))</span><br><span class="line">&#x2F;&#x2F; 1 : 1</span><br><span class="line">&#x2F;&#x2F; 4 : 4</span><br><span class="line">&#x2F;&#x2F; 9 : 9</span><br></pre></td></tr></table></figure>

<h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><h4 id="WeakSet的特点"><a href="#WeakSet的特点" class="headerlink" title="WeakSet的特点"></a>WeakSet的特点</h4><p>除了下述三个不同点外，<code>WeakSet</code>与<code>Set</code>行为一致</p>
<ol>
<li><code>WeakSet</code> 的成员只能是对象，而不能是其他类型的值。添加非对象值会报错</li>
<li><code>WeakSet</code> 中的对象都是弱引用，即垃圾回收机制不考虑 <code>WeakSet</code> 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 <code>WeakSet</code> 之中</li>
<li>由于 <code>WeakSet</code> 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 <code>WeakSet</code> 不可遍历</li>
</ol>
<h4 id="WeakSet的基本使用"><a href="#WeakSet的基本使用" class="headerlink" title="WeakSet的基本使用"></a>WeakSet的基本使用</h4><p>我们可通过<code>WeakSet</code>构造函数来创建一个<code>WeakSet</code>集合。并通过<code>add</code>方法向<code>WeakSet</code>集合中添加数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let weakset &#x3D; new WeakSet();</span><br><span class="line">weakset.add([1, 2]);</span><br><span class="line">console.log(weakset);&#x2F;&#x2F;WeakSet &#123; &lt;items unknown&gt; &#125;</span><br></pre></td></tr></table></figure>

<p><code>WeakSet</code>构造函数也可以接受一个拥有迭代器接口的数据结构作为参数，同来初始化<code>WeakSet</code>集合。但数据结构中的元素必须都是对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const a &#x3D; [[1, 2], [3, 4]];</span><br><span class="line">const ws &#x3D; new WeakSet(a);</span><br><span class="line">&#x2F;&#x2F; WeakSet &#123;[1, 2], [3, 4]&#125;</span><br></pre></td></tr></table></figure>

<p><code>WeakSet</code>也有<code>delete</code>与<code>has</code>方法（与Set一样）</p>
<p>除了上述提到的方法外，<code>WeakSet</code>不再具有其他方法</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="Map的基本使用"><a href="#Map的基本使用" class="headerlink" title="Map的基本使用"></a>Map的基本使用</h4><p>Map是特殊的对象。特殊在：Map的键和值都可以是任意类型（包括对象），而普通对象的键只能是字符串</p>
<p>Map实例的一些属性/方法如下：</p>
<ul>
<li><code>new Map()</code> —— 创建 map</li>
<li><code>map.set(key, value)</code> —— 根据键存储值</li>
<li><code>map.get(key)</code> —— 根据键来返回值，如果 map 中不存在对应的 key，则返回 undefined</li>
<li><code>map.has(key)</code> —— 如果 key 存在则返回 true，否则返回 false</li>
<li><code>map.delete(key)</code> —— 删除指定键的值</li>
<li><code>map.clear()</code> —— 清空 map</li>
<li><code>map.size</code> —— 返回当前元素个数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let map &#x3D; new Map();</span><br><span class="line">let obj &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">map.set(&#39;1&#39;, &#39;str1&#39;);   &#x2F;&#x2F; 字符串键</span><br><span class="line">map.set(1, &#39;num1&#39;);     &#x2F;&#x2F; 数字键</span><br><span class="line">map.set(true, &#39;bool1&#39;); &#x2F;&#x2F; 布尔值键</span><br><span class="line">map.set(obj, 123);&#x2F;&#x2F;对象键</span><br><span class="line"></span><br><span class="line">console.log( map.get(1)   ); &#x2F;&#x2F; &#39;num1&#39;</span><br><span class="line">console.log( map.get(&#39;1&#39;) ); &#x2F;&#x2F; &#39;str1&#39;</span><br><span class="line">console.log(map.get(true));&#x2F;&#x2F;&#39;bool1&#39;</span><br><span class="line">console.log(map.get(obj));&#x2F;&#x2F;123</span><br><span class="line">console.log( map.size ); &#x2F;&#x2F; 4</span><br></pre></td></tr></table></figure>

<p>创建Map时，也允许使用Map或者任何具有 Iterator 接口、且每个成员都是<code>[键, 值]</code>的数组的数据结构作为参数以初始化Map</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let map1 &#x3D; new Map();</span><br><span class="line">map1.set(&#39;name&#39;, &#39;德洛丽丝&#39;);</span><br><span class="line"></span><br><span class="line">let map2 &#x3D; new Map(map1);</span><br><span class="line"></span><br><span class="line">let map3 &#x3D; new Map([ [&#39;name&#39;, &#39;伯纳德&#39;] ]);</span><br><span class="line"></span><br><span class="line">console.log(map1);&#x2F;&#x2F;Map(1) &#123; &#39;name&#39; &#x3D;&gt; &#39;德洛丽丝&#39; &#125;</span><br><span class="line">console.log(map2.get(&#39;name&#39;));&#x2F;&#x2F;德洛丽丝</span><br><span class="line">console.log(map3.get(&#39;name&#39;));&#x2F;&#x2F;伯纳德</span><br><span class="line"></span><br><span class="line">&#x2F;****************&#x2F;</span><br><span class="line"></span><br><span class="line">const set &#x3D; new Set([</span><br><span class="line">  [&#39;foo&#39;, 1],</span><br><span class="line">  [&#39;bar&#39;, 2]</span><br><span class="line">]);</span><br><span class="line">const m1 &#x3D; new Map(set);</span><br><span class="line">m1.get(&#39;foo&#39;) &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<p>需要注意的是：若存在相同的键，则后面添加的键的值会覆盖掉以前的值</p>
<blockquote>
<p><code>Map</code>通过类似于<code>===</code>的算法来判断是否有元素重复。但是<code>Map</code>认为<code>NaN</code>与<code>NaN</code>是重复的</p>
</blockquote>
<h4 id="Map的遍历"><a href="#Map的遍历" class="headerlink" title="Map的遍历"></a>Map的遍历</h4><p>Map的遍历顺序就是插入顺序</p>
<ul>
<li><code>Map.prototype.keys()</code>：返回键名的遍历器</li>
<li><code>Map.prototype.values()</code>：返回键值的遍历器</li>
<li><code>Map.prototype.entries()</code>：返回所有成员的遍历器</li>
<li><code>Map.prototype.forEach()</code>：遍历 Map 的所有成员,可传入第二个参数以绑定处理函数的<code>this</code>指向</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">const map &#x3D; new Map([</span><br><span class="line">  [&#39;F&#39;, &#39;no&#39;],</span><br><span class="line">  [&#39;T&#39;,  &#39;yes&#39;],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">for (let key of map.keys()) &#123;</span><br><span class="line">  console.log(key);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; &quot;F&quot;</span><br><span class="line">&#x2F;&#x2F; &quot;T&quot;</span><br><span class="line"></span><br><span class="line">for (let value of map.values()) &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; &quot;no&quot;</span><br><span class="line">&#x2F;&#x2F; &quot;yes&quot;</span><br><span class="line"></span><br><span class="line">for (let item of map.entries()) &#123;</span><br><span class="line">  console.log(item[0], item[1]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; &quot;F&quot; &quot;no&quot;</span><br><span class="line">&#x2F;&#x2F; &quot;T&quot; &quot;yes&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 或者</span><br><span class="line">for (let [key, value] of map.entries()) &#123;</span><br><span class="line">  console.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; &quot;F&quot; &quot;no&quot;</span><br><span class="line">&#x2F;&#x2F; &quot;T&quot; &quot;yes&quot;</span><br><span class="line"></span><br><span class="line">for (let [key, value] of map) &#123;&#x2F;&#x2F;可以直接for...of...   map</span><br><span class="line">  console.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; &quot;F&quot; &quot;no&quot;</span><br><span class="line">&#x2F;&#x2F; &quot;T&quot; &quot;yes&quot;</span><br><span class="line"></span><br><span class="line">map.forEach(function(value, key, map)&#123;</span><br><span class="line">    console.log(value, key);</span><br><span class="line">    &#x2F;&#x2F; no F</span><br><span class="line">    &#x2F;&#x2F; yes T</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p>除了下述三个不同点外，<code>WeakMap</code>与<code>Map</code>行为一致</p>
<ol>
<li><code>WeakMap</code> 只接受对象作为键名（null除外）</li>
<li><code>WeakMap</code> 中的键对象都是弱引用（注意这儿是键对象，不是键对象所对应的键值是弱引用），即其他对象都不再引用该键对象，那么垃圾回收机制会自动回收该键对象所占用的内存，不考虑该键对象还存在于 <code>WeakMap</code> 之中。继而 <code>WeakMap</code> 里面的键对象和所对应的键值对会自动消失</li>
<li><code>WeakMap</code> 与 <code>Map</code> 在 API 上的区别主要是两个，一是没有遍历操作（即没有<code>keys()</code>、<code>values()</code>和<code>entries()</code>方法），也没有size属性。因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为了防止出现不确定性，就统一规定不能取到键名。二是无法清空，即不支持<code>clear</code>方法。因此，<code>WeakMap</code>只有四个方法可用：<code>get()、set()、has()、delete()</code></li>
</ol>
<p>为加深对第2点的理解，请看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const wm &#x3D; new WeakMap();</span><br><span class="line">let key &#x3D; &#123;&#125;;</span><br><span class="line">let obj &#x3D; &#123;foo: 1&#125;;</span><br><span class="line"></span><br><span class="line">wm.set(key, obj);</span><br><span class="line">obj &#x3D; null;</span><br><span class="line">wm.get(key)</span><br><span class="line">&#x2F;&#x2F; Object &#123;foo: 1&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，键值obj是正常引用。所以，即使在 WeakMap 外部消除了obj的引用，WeakMap 内部的引用依然存在(因为弱引用的是键对象，而不是键对象所对应的键值)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianghui-ma.github.io/2021/08/08/(8)%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/img/header.png">
      <meta itemprop="name" content="small_ma">
      <meta itemprop="description" content="慢慢来，比较快！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Execute">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/08/(8)%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95/" class="post-title-link" itemprop="url">(8) 对象的扩展</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-08 15:07:20" itemprop="dateCreated datePublished" datetime="2021-08-08T15:07:20+08:00">2021-08-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-08 14:15:20" itemprop="dateModified" datetime="2021-04-08T14:15:20+08:00">2021-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ES6/" itemprop="url" rel="index"><span itemprop="name">ES6</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="8-对象的扩展"><a href="#8-对象的扩展" class="headerlink" title="(8) 对象的扩展"></a>(8) 对象的扩展</h1><h3 id="属性的简洁表示法"><a href="#属性的简洁表示法" class="headerlink" title="属性的简洁表示法"></a>属性的简洁表示法</h3><p>ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let name &#x3D; &#39;德洛丽丝&#39;;</span><br><span class="line">function getName()&#123;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">let obj &#x3D; &#123;</span><br><span class="line">  name,&#x2F;&#x2F;等价于name: name</span><br><span class="line">  getName,&#x2F;&#x2F;等价于getName: getName</span><br><span class="line">  test()&#123;&#x2F;&#x2F;等价于test: test</span><br><span class="line">    console.log(&#39;西部世界&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.getName();&#x2F;&#x2F;德洛丽丝</span><br><span class="line">obj.test();&#x2F;&#x2F;西部世界</span><br></pre></td></tr></table></figure>

<p>直接写入变量/函数时，变量/函数名就是属性名，变量值/函数就是属性对应的值</p>
<h3 id="动态属性名"><a href="#动态属性名" class="headerlink" title="动态属性名"></a>动态属性名</h3><p>ES6允许使用<code>[变量/表达式]</code>来为对象设置属性或获取相应属性的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let type &#x3D; &#39;film&#39;</span><br><span class="line">let obj &#x3D; &#123;</span><br><span class="line">  [type] : &#39;西部世界&#39;</span><br><span class="line">&#125;;</span><br><span class="line">obj[&#39;na&#39; + &#39;me&#39;] &#x3D; &#39;伯纳德&#39;;</span><br><span class="line">console.log(obj.name);&#x2F;&#x2F;伯纳德</span><br><span class="line">console.log(obj.film);&#x2F;&#x2F;西部世界</span><br></pre></td></tr></table></figure>

<p>还可以定义方法名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let obj &#x3D; &#123;</span><br><span class="line">  [&#39;h&#39; + &#39;ello&#39;]() &#123;</span><br><span class="line">    return &#39;hi&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.hello() &#x2F;&#x2F; hi</span><br></pre></td></tr></table></figure>

<p>需要特别注意的是：不能将动态属性名与属性的简洁表示法混合使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const foo &#x3D; &#39;bar&#39;;</span><br><span class="line">const bar &#x3D; &#39;abc&#39;;</span><br><span class="line">const baz &#x3D; &#123;[foo]&#125;;&#x2F;&#x2F;SyntaxError</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果<code>[]</code>中不是字符串类型，则会隐式转换为字符串</p>
</blockquote>
<h3 id="遍历对象属性"><a href="#遍历对象属性" class="headerlink" title="遍历对象属性"></a>遍历对象属性</h3><p>1、<code>for...in...</code>（见“ECMAScript =&gt; (10)对象 =&gt; 属性枚举”)</p>
<p><code>for...in</code>循环遍历对象自身的和继承的可枚举属性（不含 <code>Symbol</code> 属性）</p>
<p>2、<code>Object.keys(obj)</code>（见下面“对象的新增方法”小节）</p>
<p><code>Object.keys</code>返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 <code>Symbol</code> 属性）的键名</p>
<p>3、<code>Object.getOwnPropertyNames(obj)</code></p>
<p><code>Object.getOwnPropertyNames</code>返回一个数组，包含对象自身的所有属性（不含 <code>Symbol</code> 属性，但是包括不可枚举属性）的键名</p>
<p>4、<code>Object.getOwnPropertySymbols(obj)</code></p>
<p><code>Object.getOwnPropertySymbols</code>返回一个数组，仅包含对象自身的所有 <code>Symbol</code> 属性的键名</p>
<p>5、<code>Reflect.ownKeys(obj)</code></p>
<p><code>Reflect.ownKeys</code>返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 <code>Symbol</code> 或字符串，也不管是否可枚举</p>
<h3 id="可选链操作符"><a href="#可选链操作符" class="headerlink" title="可选链操作符"></a>可选链操作符</h3><p><code>?.</code>就是可选链操作符，用于判断对象/对象属性是否存在。判断是否存在的原则是：如果对象/对象属性为<code>undefined/null</code>则不存在</p>
<p>比如，要读取<code>message.body.user.firstName</code>，安全的写法是写成下面这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 错误的写法</span><br><span class="line">const  firstName &#x3D; message.body.user.firstName;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 正确的写法</span><br><span class="line">const firstName &#x3D; (message</span><br><span class="line">  &amp;&amp; message.body</span><br><span class="line">  &amp;&amp; message.body.user</span><br><span class="line">  &amp;&amp; message.body.user.firstName) || &#39;default&#39;;</span><br></pre></td></tr></table></figure>

<p>上述使用<code>&amp;&amp;</code>层层判断十分麻烦。因此引入了链操作符来作这件事</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let message &#x3D; &#123;</span><br><span class="line">    body : &#123;</span><br><span class="line">        user : &#123;</span><br><span class="line">            firstName : 123</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let firstName &#x3D; (message ?. body ?. user ?. firstName) || &#39;default&#39;;</span><br><span class="line">console.log(firstName);&#x2F;&#x2F;123</span><br></pre></td></tr></table></figure>

<p>可这么理解上述链操作符<code>message存在吗?.message中的body存在吗?.body中的user存在吗?.user中的firstName存在吗</code></p>
<p>再举一个例子深入理解“如果对象/对象属性为<code>undefined/null</code>则不存在”这句话</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let message &#x3D; &#123;</span><br><span class="line">    body : &#123;</span><br><span class="line">        user : &#123;</span><br><span class="line">            firstName : null</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let firstName &#x3D; message ?. body ?. user ?. firstName || &#39;default&#39;;</span><br><span class="line">console.log(firstName);&#x2F;&#x2F;default</span><br></pre></td></tr></table></figure>

<p>需要注意的是，同<code>&amp;&amp;</code>一样，链判断运算符有短路机制，只要对象/对象属性不存在，则整个可选链运算式直接返回<code>undefined</code>不再向下判断</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="??运算符"></a><code>??</code>运算符</h3><p>该运算符用于判断左侧的值是否为<code>null/undefined</code>，如果是则返回右侧的值，不是则返回左侧的值。可与<code>?.</code>配合使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let message &#x3D; &#123;</span><br><span class="line">    body : &#123;</span><br><span class="line">        user : &#123;</span><br><span class="line">            &#x2F;&#x2F;firstName : 123</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let firstName &#x3D; (message ?. body ?. user ?. firstName) ?? &#39;default&#39;;</span><br><span class="line">console.log(firstName);&#x2F;&#x2F;default</span><br></pre></td></tr></table></figure>

<h3 id="使用-展开对象"><a href="#使用-展开对象" class="headerlink" title="使用...展开对象"></a>使用<code>...</code>展开对象</h3><p>虽然前面我们已经说过——<code>...</code>作展开功能时，会自动调用迭代器接口——但是ES6将其展开功能扩展到了<code>&#123;&#125;</code>对象上（虽然<code>&#123;&#125;</code>一般不具有迭代器接口）。因此我们可以使用<code>...</code>展开对象，就像展开数组那样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; &#123; a: 3, b: 4 &#125;;</span><br><span class="line">let b &#x3D; &#123; c: 5, d: 6 &#125;;</span><br><span class="line">let d &#x3D; &#123;...a, ...b&#125;;</span><br><span class="line">console.log(d);&#x2F;&#x2F;&#123; a: 3, b: 4, c: 5, d: 6 &#125;</span><br></pre></td></tr></table></figure>

<p>展开对象时，需注意下述几点：</p>
<ul>
<li>如果展开的是一个空对象，则没有任何效果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;...&#123;&#125;, a: 1&#125;</span><br><span class="line">&#x2F;&#x2F; &#123; a: 1 &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在对象中展开字符串与在数组中展开字符串是不同的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log([...&#39;hello&#39;]);&#x2F;&#x2F;[ &#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39; ]</span><br><span class="line">console.log(&#123;...&#39;hello&#39;&#125;);&#x2F;&#x2F;&#123; &#39;0&#39;: &#39;h&#39;, &#39;1&#39;: &#39;e&#39;, &#39;2&#39;: &#39;l&#39;, &#39;3&#39;: &#39;l&#39;, &#39;4&#39;: &#39;o&#39; &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>...</code>复制一个对象到另一个对象是浅拷贝</li>
</ul>
<h3 id="对象的新增方法"><a href="#对象的新增方法" class="headerlink" title="对象的新增方法"></a>对象的新增方法</h3><p>1、<code>Object.is()</code></p>
<p>用于判断两个值是否相等。其与<code>===</code>的行为一致，唯一的不同在于:一是<code>+0</code>不等于<code>-0</code>，二是<code>NaN</code>等于自身(ES5中的<code>===</code>前者相等，后者不等)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.is(&#39;foo&#39;, &#39;foo&#39;)</span><br><span class="line">&#x2F;&#x2F; true</span><br><span class="line">Object.is(&#123;&#125;, &#123;&#125;)</span><br><span class="line">&#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>2、<code>Object.assign()</code></p>
<p><code>Object.assign()</code>方法用于对象的合并，将源对象自身（source）的所有可枚举属性（包括<code>Symbol</code>属性），复制到目标对象（target）</p>
<p><code>Object.assign()</code>方法的第一个参数是目标对象，后面的参数都是源对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const target &#x3D; &#123; a: 1 &#125;;</span><br><span class="line"></span><br><span class="line">const source1 &#x3D; &#123; b: 2 &#125;;</span><br><span class="line">const source2 &#x3D; &#123; c: 3 &#125;;</span><br><span class="line"></span><br><span class="line">Object.assign(target, source1, source2);</span><br><span class="line">target &#x2F;&#x2F; &#123;a:1, b:2, c:3&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意以下几点</p>
<ul>
<li>如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const target &#x3D; &#123; a: 1, b: 1 &#125;;</span><br><span class="line"></span><br><span class="line">const source1 &#x3D; &#123; b: 2, c: 2 &#125;;</span><br><span class="line">const source2 &#x3D; &#123; c: 3 &#125;;</span><br><span class="line"></span><br><span class="line">Object.assign(target, source1, source2);</span><br><span class="line">target &#x2F;&#x2F; &#123;a:1, b:2, c:3&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果只有一个参数，<code>Object.assign()</code>会直接返回该参数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; &#123;a: 1&#125;;</span><br><span class="line">Object.assign(obj) &#x3D;&#x3D;&#x3D; obj &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Object.assign()</code>是浅拷贝</li>
</ul>
<p>3、<code>Object.setPrototypeOf()，Object.getPrototypeOf()</code></p>
<p>ES6规定所有浏览器中，对象的原型对象由<code>__proto__</code>属性表示。但是在非浏览器的其他环境中不一定部署该属性。所以我们不能通过<code>__proto__</code>设置/读取对象的原型对象</p>
<p>为此，ES6专门提供了<code>Object.setPrototypeOf(要设置的对象, 原型对象)，Object.getPrototypeOf(对象)</code>两个方法来设置/读取对象的原型对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let proto &#x3D; &#123;&#125;;</span><br><span class="line">let obj &#x3D; &#123; x: 10 &#125;;</span><br><span class="line">Object.setPrototypeOf(obj, proto);</span><br><span class="line"></span><br><span class="line">proto.y &#x3D; 20;</span><br><span class="line">proto.z &#x3D; 40;</span><br><span class="line"></span><br><span class="line">obj.x &#x2F;&#x2F; 10</span><br><span class="line">obj.y &#x2F;&#x2F; 20</span><br><span class="line">obj.z &#x2F;&#x2F; 40</span><br><span class="line"></span><br><span class="line">console.log(Object.getPrototypeOf(obj));&#x2F;&#x2F;&#123; y: 20, z: 40 &#125;</span><br></pre></td></tr></table></figure>

<p>4、<code>Object.keys()，Object.values()，Object.entries()</code></p>
<ul>
<li><code>Object.keys</code>方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名</li>
<li><code>Object.values</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值</li>
<li><code>Object.entries</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组</li>
</ul>
<p>他们都会跳过<code>Symbol</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; &#123; foo: &#39;bar&#39;, baz: 42 &#125;;</span><br><span class="line"></span><br><span class="line">Object.keys(obj)</span><br><span class="line">&#x2F;&#x2F; [&quot;foo&quot;, &quot;baz&quot;]</span><br><span class="line"></span><br><span class="line">Object.values(obj)</span><br><span class="line">&#x2F;&#x2F; [&quot;bar&quot;, 42]</span><br><span class="line"></span><br><span class="line">Object.entries(obj)</span><br><span class="line">&#x2F;&#x2F; [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]</span><br></pre></td></tr></table></figure>

<p>5、<code>Object.fromEntries()</code></p>
<p>Object.fromEntries()方法是Object.entries()的逆操作，用于将一个键值对数组转为对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object.fromEntries([</span><br><span class="line">  [&#39;foo&#39;, &#39;bar&#39;],</span><br><span class="line">  [&#39;baz&#39;, 42]</span><br><span class="line">])</span><br><span class="line">&#x2F;&#x2F; &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianghui-ma.github.io/2021/08/08/(7)%20%E8%BF%AD%E4%BB%A3%E5%99%A8Iterator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/img/header.png">
      <meta itemprop="name" content="small_ma">
      <meta itemprop="description" content="慢慢来，比较快！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Execute">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/08/(7)%20%E8%BF%AD%E4%BB%A3%E5%99%A8Iterator/" class="post-title-link" itemprop="url">(7) 迭代器Iterator</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-08 15:07:20" itemprop="dateCreated datePublished" datetime="2021-08-08T15:07:20+08:00">2021-08-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 13:56:11" itemprop="dateModified" datetime="2021-04-07T13:56:11+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ES6/" itemprop="url" rel="index"><span itemprop="name">ES6</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="7-迭代器Iterator"><a href="#7-迭代器Iterator" class="headerlink" title="(7) 迭代器Iterator"></a>(7) 迭代器Iterator</h1><h3 id="迭代器的基本概念和原理"><a href="#迭代器的基本概念和原理" class="headerlink" title="迭代器的基本概念和原理"></a>迭代器的基本概念和原理</h3><p>在详述迭代器前，我们先明晰为什么要有迭代器？什么是迭代器？</p>
<p>迭代器就是一个用于遍历数据类型的接口（即<code>Symbol.iterator</code>）。ES6规定，遍历器接口部署在数据结构的<code>Symbol.iterator</code>属性上。即一种数据结构只要部署了<code>Symbol.iterator</code>，我们就称这种数据结构是“可遍历的”（iterable）,即能通过<code>for...of...</code>遍历</p>
<p>只要拥有<code>Symbol.iterator</code>接口的数据类型都能通过<code>for...of...</code>遍历。因此迭代器的作用就是为各种不同的数据类型（如数组、Map、Set等）提供统一的遍历方法（即<code>for...of...</code>）</p>
<p>迭代器的工作原理如下：</p>
<ol>
<li><code>Symbol.iterator</code>对应的方法应返回一个遍历器对象，且该对象中必须有<code>next</code>方法</li>
<li>每一趟<code>for...of...</code>循环便会自动调用一次被遍历数据结构的<code>next</code>方法，<code>next</code>方法返回一个拥有<code>value</code>和<code>done</code>两个属性的对象。<code>value</code>表示本次遍历出的元素；<code>done</code>是一个布尔值，表示遍历是否结束</li>
</ol>
<p>下面我们为对象实现一个<code>Symbol.iterator</code>接口，以帮助理解上述内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">let obj &#x3D; &#123;</span><br><span class="line">  names : [&#39;德洛丽丝&#39;, &#39;伯纳德&#39;, &#39;黑尔&#39;, &#39;梅芙&#39;],</span><br><span class="line">  [Symbol.iterator] : function()&#123;&#x2F;&#x2F;该遍历器用于遍历对象中的names数组</span><br><span class="line">    let index &#x3D; -1;</span><br><span class="line">    let _this &#x3D; this;</span><br><span class="line">    return &#123;</span><br><span class="line">      next : function()&#123;</span><br><span class="line">        index++;</span><br><span class="line">        return &#123;</span><br><span class="line">          value : _this.names[index],</span><br><span class="line">          done : index &#x3D;&#x3D;&#x3D; _this.names.length</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">for(let name of obj)&#123;</span><br><span class="line">  console.log(name);</span><br><span class="line">  &#x2F;&#x2F; 德洛丽丝</span><br><span class="line">  &#x2F;&#x2F; 伯纳德</span><br><span class="line">  &#x2F;&#x2F; 黑尔  </span><br><span class="line">  &#x2F;&#x2F; 梅芙</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="原生迭代器接口"><a href="#原生迭代器接口" class="headerlink" title="原生迭代器接口"></a>原生迭代器接口</h3><p>当使用<code>for...of...</code>遍历时，<code>for...of...</code>会自动调用迭代器接口</p>
<p>JS中的某些数据结构原生具有迭代器接口(如下)，因此可以直接使用<code>for...of...</code>遍历</p>
<ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>TypedArray</li>
<li>函数的 arguments 对象</li>
<li>NodeList 对象</li>
</ul>
<p>下面的例子展示了数组中的原生迭代器接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];</span><br><span class="line">let iter &#x3D; arr[Symbol.iterator]();</span><br><span class="line"></span><br><span class="line">console.log(iter);&#x2F;&#x2F;&#123;next: ƒ next()&#125;</span><br><span class="line">console.log(iter.next());&#x2F;&#x2F;&#123; value: &#39;a&#39;, done: false &#125;</span><br><span class="line">console.log(iter.next());&#x2F;&#x2F;&#123; value: &#39;b&#39;, done: false &#125;</span><br><span class="line">console.log(iter.next());&#x2F;&#x2F;&#123; value: &#39;c&#39;, done: false &#125;</span><br><span class="line">console.log(iter.next());&#x2F;&#x2F;&#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure>

<p>但有的数据结构没有原生迭代器接口（如<code>&#123;&#125;</code>对象），因此不能直接使用<code>for...of...</code>遍历他们，需要手动实现迭代器接口后才能使用<code>for...of...</code>遍历（如上面的例子）</p>
<h3 id="默认调用迭代器接口的场合"><a href="#默认调用迭代器接口的场合" class="headerlink" title="默认调用迭代器接口的场合"></a>默认调用迭代器接口的场合</h3><p>下面介绍几种常见的会自动默认调用迭代器接口的场合</p>
<p>1、<code>for...of...</code>循环（见上述内容）</p>
<p>2、扩展运算符<code>...</code>作展开功能时</p>
<p>以上述第一小节中的代码为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log([...obj]);</span><br><span class="line">&#x2F;&#x2F;[ &#39;德洛丽丝&#39;, &#39;伯纳德&#39;, &#39;黑尔&#39;, &#39;梅芙&#39; ]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>所有拥有迭代器接口的数据结构都可以用<code>...</code>展开</p>
</blockquote>
<p>3、对数组和Set结构进行解构赋值时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let set &#x3D; new Set().add(&#39;a&#39;).add(&#39;b&#39;).add(&#39;c&#39;);</span><br><span class="line"></span><br><span class="line">let [x,y] &#x3D; set;</span><br><span class="line">&#x2F;&#x2F; x&#x3D;&#39;a&#39;; y&#x3D;&#39;b&#39;</span><br><span class="line"></span><br><span class="line">let [first, ...rest] &#x3D; set;</span><br><span class="line">&#x2F;&#x2F; first&#x3D;&#39;a&#39;; rest&#x3D;[&#39;b&#39;,&#39;c&#39;];</span><br></pre></td></tr></table></figure>

<p>4、<code>Array.from()</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianghui-ma.github.io/2021/08/08/(6)%20Symbol/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/img/header.png">
      <meta itemprop="name" content="small_ma">
      <meta itemprop="description" content="慢慢来，比较快！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Execute">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/08/(6)%20Symbol/" class="post-title-link" itemprop="url">(6) Symbol</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-08 15:07:20" itemprop="dateCreated datePublished" datetime="2021-08-08T15:07:20+08:00">2021-08-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-06 14:05:41" itemprop="dateModified" datetime="2021-04-06T14:05:41+08:00">2021-04-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ES6/" itemprop="url" rel="index"><span itemprop="name">ES6</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="6-Symbol"><a href="#6-Symbol" class="headerlink" title="(6) Symbol"></a>(6) Symbol</h1><p>本章主要从两个角度来讨论<code>Symbol</code>：一是<code>Symbol</code>用于生成独一无二的属性值以避免同名属性冲突（见下面“Symbol的基本用法”）；二是<code>Symbol</code>提供的内置<code>Symbol</code>值，通过它们我们可以改变对象的内置行为，即自定义对象的某些内置行为（见下面“内置Symbol值”）</p>
<h3 id="Symbol的基本用法"><a href="#Symbol的基本用法" class="headerlink" title="Symbol的基本用法"></a>Symbol的基本用法</h3><p>对象的属性名可以重复，但重复属性会发生值覆盖。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let obj &#x3D; &#123;</span><br><span class="line">  name : 123,</span><br><span class="line">  name : 456</span><br><span class="line">&#125;;</span><br><span class="line">console.log(obj.name);&#x2F;&#x2F;456</span><br></pre></td></tr></table></figure>

<p>为了解决上述问题以使每个属性名都是独一无二的，ES6引入了一种新的原始数据类型<code>Symbol</code>（其他原始类型为<code>Number, String, Boolean, undefined, null</code>）。通过<code>Symbol</code>函数生成的属性名是独一无二的，可以防止上述那样的属性名冲突</p>
<p>下面展示了如何使用<code>Symbol</code>为对象添加属性，以及如何获取<code>Symbol</code>属性的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let mySymbol &#x3D; Symbol();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加属性第一种写法</span><br><span class="line">let a &#x3D; &#123;&#125;;</span><br><span class="line">a[mySymbol] &#x3D; &#39;Hello!&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加属性第二种写法</span><br><span class="line">let a &#x3D; &#123;</span><br><span class="line">  [mySymbol]: &#39;Hello!&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加属性第三种写法</span><br><span class="line">let a &#x3D; &#123;&#125;;</span><br><span class="line">Object.defineProperty(a, mySymbol, &#123; value: &#39;Hello!&#39; &#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 以上写法都得到同样结果（获取Symbol属性的值）</span><br><span class="line">a[mySymbol] &#x2F;&#x2F; &quot;Hello!&quot;</span><br><span class="line"></span><br><span class="line">typeof mySymbol &#x2F;&#x2F;symbol</span><br></pre></td></tr></table></figure>

<p>特别注意的是，<code>Symbol</code>值作为对象属性名时，不能用点运算符。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const mySymbol &#x3D; Symbol();</span><br><span class="line">const a &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">a.mySymbol &#x3D; &#39;Hello!&#39;;</span><br><span class="line">a[mySymbol] &#x2F;&#x2F; undefined</span><br><span class="line">a[&#39;mySymbol&#39;] &#x2F;&#x2F; &quot;Hello!&quot;</span><br></pre></td></tr></table></figure>

<p>我们知道，<code>.</code>后面的内容会被视为字符串，所以不能使用点运算符</p>
<h3 id="为Symbol属性添加描述信息"><a href="#为Symbol属性添加描述信息" class="headerlink" title="为Symbol属性添加描述信息"></a>为Symbol属性添加描述信息</h3><p>在使用<code>Symbol</code>函数生成属性名时，我们可以为生成的属性名添加一些描述信息，以便区分不同的<code>Symbol</code>属性名。我们可通过直接传参给<code>Symbol</code>来添加描述</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let s1 &#x3D; Symbol(&#39;foo&#39;);</span><br><span class="line">let s2 &#x3D; Symbol(&#39;bar&#39;);</span><br><span class="line"></span><br><span class="line">console.log(s1); &#x2F;&#x2F; Symbol(foo)</span><br><span class="line">console.log(s2); &#x2F;&#x2F; Symbol(bar)</span><br></pre></td></tr></table></figure>

<p>除了通过上述打印<code>Symbol</code>值查看描述信息外。如果想要直接获取某个<code>Symbol</code>值的描述信息，还可以使用<code>description</code>属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(s1.description); &#x2F;&#x2F; foo</span><br><span class="line">console.log(s2.description); &#x2F;&#x2F; bar</span><br></pre></td></tr></table></figure>

<p>需要注意的是，<code>Symbol</code>函数的参数只是表示对当前<code>Symbol</code>值的描述，因此相同参数的<code>Symbol</code>函数的返回值是不相等的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 没有参数的情况</span><br><span class="line">let s1 &#x3D; Symbol();</span><br><span class="line">let s2 &#x3D; Symbol();</span><br><span class="line"></span><br><span class="line">s1 &#x3D;&#x3D;&#x3D; s2 &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 有参数的情况</span><br><span class="line">let s1 &#x3D; Symbol(&#39;foo&#39;);</span><br><span class="line">let s2 &#x3D; Symbol(&#39;foo&#39;);</span><br><span class="line"></span><br><span class="line">s1 &#x3D;&#x3D;&#x3D; s2 &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<h3 id="Symbol属性名的遍历"><a href="#Symbol属性名的遍历" class="headerlink" title="Symbol属性名的遍历"></a>Symbol属性名的遍历</h3><p>Symbol 作为属性名，遍历对象的时候，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回</p>
<p>我们可通过<code>Object.getOwnPropertySymbols()</code>来获取一个对象的所有<code>Symbol</code>属性名。或者通过<code>Reflect.ownKeys()</code>返回对象的所有键名（包括常规键名和<code>Symbol</code>键名）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; &#123;&#125;;</span><br><span class="line">const foo &#x3D; Symbol(&#39;foo&#39;);</span><br><span class="line"></span><br><span class="line">obj[foo] &#x3D; &#39;bar&#39;;</span><br><span class="line"></span><br><span class="line">for (let i in obj) &#123;</span><br><span class="line">  console.log(i); &#x2F;&#x2F; 无输出</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyNames(obj) &#x2F;&#x2F; []</span><br><span class="line">Object.getOwnPropertySymbols(obj) &#x2F;&#x2F; [Symbol(foo)]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let obj &#x3D; &#123;</span><br><span class="line">  [Symbol(&#39;my_key&#39;)]: 1,</span><br><span class="line">  enum: 2,</span><br><span class="line">  nonEnum: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Reflect.ownKeys(obj)</span><br><span class="line">&#x2F;&#x2F;  [&quot;enum&quot;, &quot;nonEnum&quot;, Symbol(my_key)]</span><br></pre></td></tr></table></figure>

<h3 id="内置Symbol值"><a href="#内置Symbol值" class="headerlink" title="内置Symbol值"></a>内置Symbol值</h3><p>除了通过<code>Symbol</code>生成属性值外，<code>Symbol</code>还有另一个应用场景：<code>Symbol</code>提供了 11 个内置的 <code>Symbol</code> 值（即<code>Symbol</code>的一些属性），而这些内置值的作用就是用于作为对象的属性，以控制对象的某些行为或扩充添加对象的功能（比如后面章节我们将通过，将内置值<code>Symbol.iterator</code>作为对象的属性来为对象添加遍历功能）</p>
<p>下面我们再通过一个例子来阐述内置Symbol值的作用。在此我们用<code>Symbol.isConcatSpreadable</code>举例：</p>
<p><code>Symbol.isConcatSpreadable</code>属性等于一个布尔值，表示该对象用于<code>Array.prototype.concat()</code>时，是否可以展开</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let arr1 &#x3D; [&#39;c&#39;, &#39;d&#39;];</span><br><span class="line">[&#39;a&#39;, &#39;b&#39;].concat(arr1, &#39;e&#39;) &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]</span><br><span class="line"></span><br><span class="line">let arr2 &#x3D; [&#39;c&#39;, &#39;d&#39;];</span><br><span class="line">arr2[Symbol.isConcatSpreadable] &#x3D; false;</span><br><span class="line">[&#39;a&#39;, &#39;b&#39;].concat(arr2, &#39;e&#39;) &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, [&#39;c&#39;,&#39;d&#39;], &#39;e&#39;]</span><br></pre></td></tr></table></figure>

<p>上面代码说明，在<code>contact</code>时，数组的默认行为会展开。但我们可通过为数组对象设置<code>Symbol.isConcatSpreadable</code>为<code>false</code>使该数组在合并时不展开，从而控制数组对象的行为</p>
<p>其他内置Symbol值便不再一一阐述，需要时查阅即可</p>
<h3 id="Symbol的注意事项"><a href="#Symbol的注意事项" class="headerlink" title="Symbol的注意事项"></a>Symbol的注意事项</h3><p>1、Symbol生成的值可以显式转为字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let sym &#x3D; Symbol(&#39;My symbol&#39;);</span><br><span class="line"></span><br><span class="line">String(sym) &#x2F;&#x2F; &#39;Symbol(My symbol)&#39;</span><br><span class="line">sym.toString() &#x2F;&#x2F; &#39;Symbol(My symbol)&#39;</span><br></pre></td></tr></table></figure>

<p>2、Symbol生成的值不能进行算术、比较等运算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let s1 &#x3D; Symbol(&#39;foo&#39;);</span><br><span class="line"></span><br><span class="line">console.log(s1 + 1);&#x2F;&#x2F;TypeError: Cannot convert a Symbol value to a number</span><br></pre></td></tr></table></figure>











      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="small_ma"
      src="/img/header.png">
  <p class="site-author-name" itemprop="name">small_ma</p>
  <div class="site-description" itemprop="description">慢慢来，比较快！</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">78</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xianghui-ma" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xianghui-ma" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:3291891717@qq.com" title="E-Mail → mailto:3291891717@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user-circle"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">small_ma</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">277k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:12</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
